<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weiwenhao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://beian.miit.gov.cn/"/>
  <updated>2019-12-09T04:32:11.000Z</updated>
  <id>http://beian.miit.gov.cn/</id>
  
  <author>
    <name>粤ICP备18153286</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的键盘使用指南</title>
    <link href="http://beian.miit.gov.cn/posts/programmer-keyboard-usage-guide.html"/>
    <id>http://beian.miit.gov.cn/posts/programmer-keyboard-usage-guide.html</id>
    <published>2019-01-24T03:11:09.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事,必先利其器. 键盘便是其中的重要的一环,高效的使用键盘可以带来优雅高效的日常使用及编码,甚至能够保护好你的手指.</p><p>于是我便收集了一些较为通用并且不错的键盘使用实践,其中大部分都是参考一些键盘的历史设计,程序员的编码实践,以及一些键盘的使用标准,如键盘使用标准指法等.</p><p>经过这一年的使用,发现很多实践确实会让编码更加的优雅高效,遂分享出来.下面的文章较为简短,只有几条程序员间较为通用的做法,并给出了这么做的理由. </p><a id="more"></a><blockquote><p>一些我个人的键盘使用习惯就不阐述了~</p></blockquote><h4 id="尊重你的操作系统"><a href="#尊重你的操作系统" class="headerlink" title="尊重你的操作系统"></a>尊重你的操作系统</h4><p>如果你使用了mac相关的电脑并外接了非苹果键盘,需要注意一下 command键和option的位置. 更为标准且习惯的方式应该是 alt设置为command键,win设置为option键. </p><p>设置的方式也很简单,点击<strong>键盘 -&gt; 修饰键</strong> 进行设置即可.</p><p><img src="http://asset.eienao.com/20190117095146.png" alt></p><blockquote><p>实际上,我认为mac os的设计相比于windows/linux 在这点上更加合理</p></blockquote><h4 id="抛弃Caps键"><a href="#抛弃Caps键" class="headerlink" title="抛弃Caps键"></a>抛弃Caps键</h4><p>caps既大小写锁定键,相信很多人已经很少去按这个键了,如果你还对它恋恋不舍,那么你需要练习使用shift键来进行大小写的转换. </p><blockquote><p>推荐一个练习打字的网站 <a href="https://www.typingclub.com" target="_blank" rel="noopener">https://www.typingclub.com</a></p><p>如果整个单词需要大写的话,我通常会先键入小写,然后使用ide的大小写转换功能对整个单词进行转换(适用于常量的键入), 对于vim只要<code>gUaw</code>即可将整个单词切换为大写,对于jetbrains系列ide,选中单词后按住<code>command + shift + u</code> 即可进行大小写的转换</p><p>在window/linux上 command 即 ctrl键</p></blockquote><h4 id="使用两侧的Shift键"><a href="#使用两侧的Shift键" class="headerlink" title="使用两侧的Shift键"></a>使用两侧的Shift键</h4><p>考虑到你可能不会点开上面的打字网站,我着重介绍一下shift键. 稍微注意一下你就会发现 shift键的使用频率非常的高, 尤其是php程序员满屏的$,如果你还使用shift切换大小写,那么你的左手小指的负担其实已经非常大了</p><p>正确的做法是</p><p>键入<code>A</code>时, 标准指法的使用应该是<strong>右手小指按住shift + 左手小指按住字母A</strong>.  </p><p>键入<code>$</code>时, 应该是<strong>右手小指按住shift + 左手食指按住数字4</strong></p><p>键入<code>(</code>时, 应该是<strong>左手小指按住shift + 左手食指按住数字9</strong></p><p>这里的基本原则是,如果你需要同时按住两个按键时,尽量让这两个按键分摊到你的两只手上</p><blockquote><p>但是如 ctrl + c    ctrl + d 这样的按键,还是无法分摊到两只手上进行操作</p></blockquote><h4 id="映射Ctrl键"><a href="#映射Ctrl键" class="headerlink" title="映射Ctrl键"></a>映射Ctrl键</h4><p>当不在使用caps键键入大写字母时,就空出了一个非常宝贵的按键, 因为caps对应的这个键位对小拇指实在是太友好了.</p><p>接下来要做的就是把日常生活中程序员非常非常常用但却非常难于敲击的键ctrl键映射到caps键.这一步对于非常依赖ctrl的windows/linux用户尤为重要. 当然对于mac用户也非常重要,即使在command键已经代替了ctrl的大部分操作的情况下.</p><blockquote><p>crtl + [ 是我日常使用最为频繁的按键</p></blockquote><p>对于mac用户这很容易操作,你可以参考上面那张图片中的按键映射, 对于windows/linux用户,你需要下载专业的按键映射软件</p><h4 id="映射Esc键"><a href="#映射Esc键" class="headerlink" title="映射Esc键"></a>映射Esc键</h4><p>esc也是较为常用的一个按键,尤其是用在一些弹出层的关闭. vim中退出insert/visual模式也需要esc键.但是esc实在是太太太遥远了.</p><p>这里有两个映射方案</p><p>对于非vim用户,可以选择将键盘左下角空出来的Ctrl按键映射成Esc. 如果你的键盘按键足够高,可以选择使用掌心来敲击该按键. <em>对于我来说,这种映射使用最多的情况是退出视频的全屏模式</em></p><blockquote><p>vim用户请千万不要使用上述的方式退出insert/visual模式</p></blockquote><p>对于vim模式,推荐使用<code>ctrl + [</code> 代替Esc键,在vim编辑器中,这是默认映射.当然我也喜欢自己在系统层面做这样一个映射,让我在任何地方都能够使用<code>ctrl + [</code>来退出一些奇奇怪怪的弹出层,比如Alfred</p><p>下面是我常用的一些映射</p><p><img src="http://asset.eienao.com/20190124103742.png" alt></p><p><img src="http://asset.eienao.com/20190124135715.png" alt></p><p>上面的键盘映射软件是 <a href="https://pqrs.org/osx/karabiner/" target="_blank" rel="noopener">Karabiner for mac</a>,由于我的键盘的特殊性,所以做了一些特别的映射,下面有介绍我使用的键盘</p><h4 id="抛弃↑↓←→"><a href="#抛弃↑↓←→" class="headerlink" title="抛弃↑↓←→"></a>抛弃↑↓←→</h4><p>上下左右这几个键依旧非常的遥远,会让我们的手指离开主键位区. 这里有两种方法来避免使用它们,让你更有style的来工作与日常</p><p>emacs的解决方式(通用解决方式). </p><p><code>ctrl + b</code> = ←</p><p><code>ctrl + f</code> = →</p><p><code>ctrl + n</code> = ↓</p><p><code>ctrl + p</code> = ↑</p><p>说上面的为通用解决方案是因为上面的指法只要是在有文本键入的地方都适用的,包含iterm2,浏览器,ide中等等.基本上属于操作系统级的指法</p><p>更多的类似指法还有</p><p><code>ctrl + a</code> 回到行首</p><p><code>ctrl + e</code> 去到行尾</p><p><code>ctrl + w</code> 回删一个单词</p><p><code>ctrl + m</code>  回车</p><p>vim的解决方式,这个就不多叙述了,适用群体和软件比较特殊,不过我还是推荐 phpstorm + vim插件 / vscode + vim插件的开发方式,在简单的层面使用vim也会带来很多的便利</p><h4 id="抛弃数字小键盘"><a href="#抛弃数字小键盘" class="headerlink" title="抛弃数字小键盘"></a>抛弃数字小键盘</h4><p>使用主键位区的数字键</p><p><img src="http://asset.eienao.com/20190124104710.png" alt></p><h4 id="选用一把合适的键盘"><a href="#选用一把合适的键盘" class="headerlink" title="选用一把合适的键盘"></a>选用一把合适的键盘</h4><p>即使ctrl在一个这么顺手的位置,但是对于程序员来说左手小指的压力还是非常大的,尤其是左侧shift和ctrl的使用,我便是由于小拇指疼痛,便购入了一把<strong>樱桃红轴</strong>的机械键盘,其对小拇指的减负有着不错的作用</p><p>下面这款是我编码使用的键盘</p><p><img src="http://asset.eienao.com/20190117105613.png" alt></p><p>算是比较便宜精致的樱桃轴键盘了,基本上没有多余的键位</p><p>我没有体验过静电容的键盘, 但是预算充足的情况下, hhkb的那款感觉很酷,值得尝试</p><blockquote><p>tip: 如果你要购入和我一样的键盘,请一定要看准<strong>樱桃红轴</strong>,这款键盘还有其他品牌的轴体</p></blockquote><h4 id="尝试学习vim"><a href="#尝试学习vim" class="headerlink" title="尝试学习vim"></a>尝试学习vim</h4><p>理由网上很多我就不赘述了, 但是写两行代码就要动一下鼠标或者手指离开主键盘区,感觉自己就像是个瘸子一样,很不酷.😂</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><em>推荐使用右手拇指来敲击空格,从而充分利用该手指. 当然更加推荐的做法是双手拇指轮流敲击空格(我还做不到). 程序员对空格的需求还是蛮大的</em></p><p><em>不要总是展开ide左侧的tree文件导航,实际上大部分时间你都用不到它,记住展开与关闭的快捷键,编码时把它关闭(jetbrains系列ide的快捷键是command + 1)</em></p><p><em>编码时推荐使用serach Everywhere + 缓冲区(jetbrains系列ide中 command + e)  + 函数列表(jetbrains系列ide中 command + f12)来进行跳转与控制</em></p><p><em>实际上一把HHKB键盘包含上述80%的操作,毕竟是专门为程序员打造的键盘.但是并不是每个人都舍得购入一把HHKB,所以上面的一些操作方法,使你依旧能够在普通键盘上使用</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事,必先利其器. 键盘便是其中的重要的一环,高效的使用键盘可以带来优雅高效的日常使用及编码,甚至能够保护好你的手指.&lt;/p&gt;
&lt;p&gt;于是我便收集了一些较为通用并且不错的键盘使用实践,其中大部分都是参考一些键盘的历史设计,程序员的编码实践,以及一些键盘的使用标准,如键盘使用标准指法等.&lt;/p&gt;
&lt;p&gt;经过这一年的使用,发现很多实践确实会让编码更加的优雅高效,遂分享出来.下面的文章较为简短,只有几条程序员间较为通用的做法,并给出了这么做的理由. &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用TreeQL加速你的api开发</title>
    <link href="http://beian.miit.gov.cn/posts/accelerate-your-api-development-with-tree-ql.html"/>
    <id>http://beian.miit.gov.cn/posts/accelerate-your-api-development-with-tree-ql.html</id>
    <published>2019-01-21T08:04:20.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是TreeQL"><a href="#什么是TreeQL" class="headerlink" title="什么是TreeQL"></a>什么是TreeQL</h2><p>tree-ql 是一个laravel扩展,希望能够从url中include你所需的资源,实现查询的所见既所得.</p><a id="more"></a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// http://api.test/posts/&#123;slug&#125;?include=content,user,comments  ↓</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"slug"</span>: <span class="string">"quisquam-asperiores-est-necessitatibus-et."</span>,</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"Quisquam asperiores est necessitatibus et."</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Officiis nihil sunt ut veritatis."</span>,</span><br><span class="line">        <span class="attr">"cover"</span>: <span class="string">"https://lorempixel.com/640/480/?63535"</span>,</span><br><span class="line">        <span class="attr">"comment_count"</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">"like_count"</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"Omnis quisquam dolorem quasi sequi veritatis quia dolorem sed. Ut non voluptatem beatae eum. "</span>,</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">303</span>,</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"Quasi dignissimos dolor tempore exercitationem."</span>,</span><br><span class="line">            <span class="attr">"user_id"</span>: <span class="number">2481</span>,</span><br><span class="line">            <span class="attr">"post_id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"like_count"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="attr">"reply_count"</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="attr">"floor"</span>: <span class="number">303</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">1221</span>,</span><br><span class="line">          <span class="attr">"nickname"</span>: <span class="string">"Ashleigh McKenzie"</span>,</span><br><span class="line">          <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?29515"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加深入的使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// http://api.test/posts/&#123;slug&#125;?include=</span><br><span class="line">// content,user,comments(sort_by:like_count)&#123;user,replies.user&#125;,is_like,select_comments</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"slug"</span>: <span class="string">"quisquam-asperiores-est-necessitatibus-et."</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Quisquam asperiores est necessitatibus et."</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Officiis nihil sunt ut veritatis."</span>,</span><br><span class="line">    <span class="attr">"cover"</span>: <span class="string">"https://lorempixel.com/640/480/?63535"</span>,</span><br><span class="line">    <span class="attr">"comment_count"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"like_count"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>: <span class="number">1221</span>,</span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"Omnis quisquam dolorem quasi sequi veritatis quia dolorem sed. Ut non voluptatem beatae eum."</span>,</span><br><span class="line">    <span class="attr">"is_like"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"comments"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">303</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"Quasi dignissimos dolor tempore exercitationem."</span>,</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="number">2481</span>,</span><br><span class="line">        <span class="attr">"post_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"like_count"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">"reply_count"</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="attr">"floor"</span>: <span class="number">303</span>,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">2481</span>,</span><br><span class="line">          <span class="attr">"nickname"</span>: <span class="string">"Garett O'Connell"</span>,</span><br><span class="line">          <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?52652"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"replies"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">415</span>,</span><br><span class="line">            <span class="attr">"comment_id"</span>: <span class="number">303</span>,</span><br><span class="line">            <span class="attr">"user_id"</span>: <span class="number">2814</span>,</span><br><span class="line">            <span class="attr">"content"</span>: <span class="string">"Odit magnam sed ut."</span>,</span><br><span class="line">            <span class="attr">"call_user"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"created_at"</span>: <span class="string">"2018-12-12 02:26:08"</span>,</span><br><span class="line">            <span class="attr">"updated_at"</span>: <span class="string">"2018-12-12 02:26:08"</span>,</span><br><span class="line">            <span class="attr">"user"</span>: &#123;</span><br><span class="line">              <span class="attr">"id"</span>: <span class="number">2814</span>,</span><br><span class="line">              <span class="attr">"nickname"</span>: <span class="string">"Ted Dickinson"</span>,</span><br><span class="line">              <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?19577"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1221</span>,</span><br><span class="line">      <span class="attr">"nickname"</span>: <span class="string">"Ashleigh McKenzie"</span>,</span><br><span class="line">      <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?29515"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"meta"</span>: &#123;</span><br><span class="line">    <span class="attr">"selected_comments"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">303</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"Quasi dignissimos dolor tempore exercitationem."</span>,</span><br><span class="line">        <span class="attr">"user_id"</span>: <span class="number">2481</span>,</span><br><span class="line">        <span class="attr">"post_id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"like_count"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">"reply_count"</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="attr">"floor"</span>: <span class="number">303</span>,</span><br><span class="line">        <span class="attr">"selected"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"created_at"</span>: <span class="string">"2018-12-12 02:25:55"</span>,</span><br><span class="line">        <span class="attr">"updated_at"</span>: <span class="string">"2018-12-12 02:25:55"</span>,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">2481</span>,</span><br><span class="line">          <span class="attr">"nickname"</span>: <span class="string">"Garett O'Connell"</span>,</span><br><span class="line">          <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?52652"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会发现和GraphQL比起来并不是真正的所见既所得,这是由于http请求url长度的限制,所以加入了default的概念, TreeQL会结合include和default来返回相应的资源.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>确保你的laravel版本在5.5以上,在项目目录下执行</p><p><code>composer require weiwenhao/tree-ql</code></p><blockquote><p>该版本目前为alpha版本,不推荐用于商业生产环境,推荐用于个人项目</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由于tree-ql是一个laravel的扩展包,接下来会从laravel的角度进行切入,实际上如果你熟悉 dingo/api的include,你会更加适应这种开发模式.</p><h4 id="我可以include什么东西"><a href="#我可以include什么东西" class="headerlink" title="我可以include什么东西?"></a>我可以include什么东西?</h4><p>由于include所见即所得,因此可以换个提问方式,我的response中可以返回些什么数据?</p><p>response中的数据可以分为4类, 既 <strong>columns,relations,each,meta.</strong> </p><p>columns 既我们数据库中的columns, 如 id,name,created_at,updated_at等</p><p>relations 既orm中的关联关系, 比如post资源的relation有一对一的 user,一对多的 comments, 具体的定义都在laravel的model中定义</p><p>each 可以理解为没有存储在mysql中,由程序员计算得来的column, 其和column是平级的, 比如 一个user是否点赞了一篇post, 那么在我们的post的response中可能会见到这样的数据 ↓</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"slug"</span>: <span class="string">"quisquam-asperiores-est-necessitatibus-et."</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Quisquam asperiores est necessitatibus et."</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Officiis nihil sunt ut veritatis."</span>,</span><br><span class="line">            "is_like": true, // 该字段由程序员计算得来, 没有也不能存储在数据库中</span><br><span class="line">    &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"slug"</span>: <span class="string">"quisquam-asperiores-est-necessitatibus-et."</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Quisquam asperiores est necessitatibus et."</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"Officiis nihil sunt ut veritatis."</span>,</span><br><span class="line">            <span class="attr">"is_like"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta 用来存储一些无法存储在data中的数据, 最典型的例子既分页信息 ↓</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">285</span>,</span><br><span class="line">      <span class="attr">"slug"</span>: <span class="string">"repellat-illo-molestias-quidem-ea-autem."</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"Repellat illo molestias quidem ea autem."</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Sed harum."</span>,</span><br><span class="line">      <span class="attr">"cover"</span>: <span class="string">"https://lorempixel.com/640/480/?12347"</span>,</span><br><span class="line">      <span class="attr">"comment_count"</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"like_count"</span>: <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"user_id"</span>: <span class="number">2023</span></span><br><span class="line">    &#125;,</span><br><span class="line">    // ...</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"meta"</span>: &#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">      <span class="attr">"per_page"</span>: <span class="number">15</span>,</span><br><span class="line">      <span class="attr">"total"</span>: <span class="number">300</span>,</span><br><span class="line">      <span class="attr">"current"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"next"</span>: <span class="string">"http://api.jianshu.test/api/posts?page=2"</span>,</span><br><span class="line">      <span class="attr">"previous"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"last"</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看如何在laravel中进行定义</p><h4 id="Resource的定义"><a href="#Resource的定义" class="headerlink" title="Resource的定义"></a>Resource的定义</h4><p>tree-ql默认使用app下的Resources目录, 因此可能会有这样的目录结构</p><p><img src="http://asset.eienao.com/20190118180524.png" alt></p><p>接下来以PostResource为例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Resources</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Weiwenhao</span>\<span class="title">TreeQL</span>\<span class="title">Resource</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostResource</span> <span class="keyword">extends</span> <span class="title">Resource</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面的 columns/relations/meta/each中抽取得来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> $default = [</span><br><span class="line">        <span class="string">'id'</span>,</span><br><span class="line">        <span class="string">'slug'</span>,</span><br><span class="line">        <span class="string">'title'</span>,</span><br><span class="line">        <span class="string">'description'</span>,</span><br><span class="line">        <span class="string">'cover'</span>,</span><br><span class="line">        <span class="string">'comment_count'</span>,</span><br><span class="line">        <span class="string">'like_count'</span>,</span><br><span class="line">        <span class="string">'user_id'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $columns = [</span><br><span class="line">        <span class="string">'id'</span>,</span><br><span class="line">        <span class="string">'slug'</span>,</span><br><span class="line">        <span class="string">'title'</span>,</span><br><span class="line">        <span class="string">'description'</span>,</span><br><span class="line">        <span class="string">'cover'</span>,</span><br><span class="line">        <span class="string">'comment_count'</span>,</span><br><span class="line">        <span class="string">'like_count'</span>,</span><br><span class="line">        <span class="string">'user_id'</span>,</span><br><span class="line">        <span class="string">'content'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $relations = [</span><br><span class="line">        <span class="string">'user'</span>,</span><br><span class="line">        <span class="string">'comments'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $meta = [</span><br><span class="line">        <span class="string">'selected_comments'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $each = [<span class="string">'is_like'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLike</span><span class="params">($item, $params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array_random([<span class="keyword">true</span>, <span class="keyword">false</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selectedComments</span><span class="params">($params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $post = <span class="keyword">$this</span>-&gt;getCollection()-&gt;first();</span><br><span class="line"></span><br><span class="line">        $comments = $post-&gt;selectedComments;</span><br><span class="line"></span><br><span class="line">        $resource = CommentResource::make($comments, <span class="string">'user,replies.user'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $resource-&gt;getResponseData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resource分为两部分, <strong>类属性部分</strong>用来进行定义,除了default外,其余部分 columns/relations/meta/each 中定义的value 都可以在include中被引入.</p><p>而default中的定义则是从 columns/relations/meta/each 中已经定义的value进行抽取,default中的key,会被默认include进来,而不需要再url中显式的定义.</p><p><strong>方法部分</strong> 目前的作用主要是回调函数, 且只有each和meta中定义的value 需要callback. callback命名的规则也很简单, 既将meta或者each中定义的值改为 小驼峰命名 作为方法名称即可.</p><p>each的callback有两个参数,  每一个resource下都有一个collection属性, 其中存放了该Resource下的资源数据, 其类型为<code>Illuminate\Database\Eloquent\Collection</code> ,collection中的每一个item都会被callback一次, 所以 上面 isLike的第一个参数为 Collection中的一个item, item既model </p><blockquote><p>在Resource中通过调用 $this-&gt;getCollection()可以获取所有的数据</p></blockquote><p>由于include支持params, 所以isLike的第二个参数为include中传递的params, 类型为array,格式为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$params = [</span><br><span class="line">    <span class="string">'sort_by'</span> =&gt; <span class="string">'created_at'</span>,</span><br><span class="line">    <span class="string">'order'</span> =&gt; <span class="string">'desc'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>callback 中 return的值将会在response data中被原样展示</p><p><strong>关于meta</strong></p><p>meta不同于each, 每个include meta在其生命周期中只会被调用一次.且只有一个参数 既params. 其return的值也将在response meta中被原样展示</p><p>meta的另一个特点时,只有最外层的数据结构才存在meta, 即</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    meta: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此如果在更深层次的resource中进行include meta 那么会产生的行为时, 该meta数据,被拉到了最外层. 举个例子</p><p><code>include=meta1,post.meta2</code>  那么返回的结果是</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        post: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">        meta1: &#123;&#125;,</span><br><span class="line">        meta2: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个行为我并不是很喜欢,所以在考虑更加合适的解决方案</p><p><strong>Columns</strong> 中定义了orm select语句中可以被查询的数据,既类似这样的行为会使用columns</p><p><img src="http://asset.eienao.com/20190121115105.png" alt></p><h4 id="使用Resource"><a href="#使用Resource" class="headerlink" title="使用Resource"></a>使用Resource</h4><p>接下来看看PostController的index和show方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Display a listing of the resource.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> \Weiwenhao\TreeQL\Resource</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// $posts = Post::columns()-&gt;latest()-&gt;get(); 同样支持</span></span><br><span class="line">       $posts = Post::columns()-&gt;latest()-&gt;paginate();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 等价于 return PostResource::make($post, request('include'))</span></span><br><span class="line">       <span class="keyword">return</span> PostResource::make($posts);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Display the specified resource.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  \App\Models\Post $post</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> \Weiwenhao\TreeQL\Resource</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">($post)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> $resource = PostResource::make($post);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的使用非常的简单, 唯一需要讲解的便是 columns() 这个查询构造器. 我不希望Post的查询一下查询出table中所有的column,而是根据url中include进行查询. 所以columns()会解析url中include并结合resource中的定义进行合适的select.</p><h4 id="include的语法规则"><a href="#include的语法规则" class="headerlink" title="include的语法规则"></a>include的语法规则</h4><p>已实例进行讲解</p><p><code>http://api.test/posts/{slug}?include=user</code>  基础使用,在post的基础上 include 这篇post的作者</p><p><strong>我想include PostResource中定义的更多的东西怎么办?</strong></p><p><code>http://api.test/posts/{slug}?include=user,content,comments</code> 使用逗号进行分割</p><p><strong>我想引入comment中的user怎么办?</strong></p><p><code>http://api.test/posts/{slug}?include=user,content,comments.user</code>使用<code>.</code>进行嵌套</p><p><strong>我想同时引入comment中的user和replies怎么做?</strong></p><p><code>http://api.test/posts/{slug}?include=user,content,comments{user,replies}</code>  使用 <code>{}</code> 和 <code>,</code> 来代替<code>.</code>语法进行嵌套</p><blockquote><p>在dingo/api中 你可能需要这么做  <code>include=comment.user,comment.replies</code></p></blockquote><p><strong>我想对include的comments添加一些条件我应该怎么做?</strong></p><p><code>http://api.test/posts/{slug}?include=user,content,comments(sort_by:created_at,order:desc){user,replies}</code>  条件语法紧跟着comments, <code>()</code>中包围的既params,  形式为 <code>key1:value1,key2:value2</code></p><blockquote><p>实际上 目前只有 each和meta支持回调.  后续会对columns和relations添加回调.到时params将会有更强大的作用</p></blockquote><p><strong>这就是 include的所有语法规则了, 理论上所有的语法规则都支持无限嵌套与任意组合</strong></p><p>比如 <code>include=a,b.c.d,c{b},c{b(f:b),a.b.c},c(b.a),c{f,b}.b(a:b).c</code> </p><p><strong>当然无论怎样的组合嵌套,你都无需担心n+1的问题</strong></p><h2 id="下一步的计划"><a href="#下一步的计划" class="headerlink" title="下一步的计划"></a>下一步的计划</h2><ul><li><p>为column 和 relations添加回调.</p></li><li><p>添加单元测试</p></li><li><p>为定义添加一些基础功能 比如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $relations = [</span><br><span class="line">    <span class="string">'user'</span> =&gt; [</span><br><span class="line">        <span class="string">'resource'</span> =&gt; UserResource::class,</span><br><span class="line">        <span class="string">'alias'</span> =&gt; <span class="string">'vip'</span>,</span><br><span class="line">        <span class="string">'builder'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">($builder, $params)</span> </span>&#123;</span><br><span class="line">            $builder-&gt;orderBy($params[<span class="string">'sort_by'</span>], $params[<span class="string">'order'</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'comments'</span> =&gt; [</span><br><span class="line">        <span class="string">'alias'</span> =&gt; <span class="string">'test_comment'</span>,</span><br><span class="line">        <span class="string">'auth'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">($version)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// or false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>php并不支持回调式的写法,所以需要计划一下解决方案, 以及引入哪些基本功能</p></blockquote></li><li><p>添加中文及英文文档</p></li></ul><p>实际上在几个月前,该项目就基本完成了.受到工作影响搁置,最后一点收尾始终无法完成,我不想这个项目付诸东流,所以在年前赶一波进度.</p><p>希望大家发表自己的想法与意见,争取尽快发布1.0版本,在商业项目上有用武之地</p><p><a href="https://github.com/weiwenhao/tree-ql" target="_blank" rel="noopener">https://github.com/weiwenhao/tree-ql</a> 欢迎Star~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是TreeQL&quot;&gt;&lt;a href=&quot;#什么是TreeQL&quot; class=&quot;headerlink&quot; title=&quot;什么是TreeQL&quot;&gt;&lt;/a&gt;什么是TreeQL&lt;/h2&gt;&lt;p&gt;tree-ql 是一个laravel扩展,希望能够从url中include你所需的资源,实现查询的所见既所得.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>E-commerce 中促销系统的设计</title>
    <link href="http://beian.miit.gov.cn/posts/design-of-promotion-system-in-e-commerce.html"/>
    <id>http://beian.miit.gov.cn/posts/design-of-promotion-system-in-e-commerce.html</id>
    <published>2018-12-26T08:04:20.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在电商平台中,促销是必不可少的营销手段,尤其在国内 各种玩法层出不穷,最开始的满减/秒杀 到优惠卷 再到 拼团/砍价等等</p><p>一个良好的促销系统应该具备易于扩展,易于统计促销效果等特点,在遇到秒杀类促销时还需要做到可扩容,抗并发(本次不考虑秒杀系统的设计)等等.  废话说完了,进入正题吧</p><a id="more"></a><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="http://asset.eienao.com/18-12-25/96451684.jpg" alt></p><p>对各种促销行为进行分析,会发现本质上是由两个部分和一个作用域组成.</p><p><strong>促销的核心作用域既订单</strong>.因此我在上一篇文章中介绍了电商中订单系统的设计 <a href="https://laravel-china.org/articles/21461" target="_blank" rel="noopener">E-commerce 中订单系统的设计</a></p><p>两个部分既上图中的rule和action部分. </p><p><strong>rule描述了促销限制</strong>,既订单需要满足那些条件才能参与某个促销.常见的促销限制有 订单金额/购买时间/购买数量/收货地址/支付方式/用户类型/购买人数 等等.</p><p><strong>action描述了给予订单哪些优惠策略</strong> 如折扣/直减/免运费/返现/赠品 等等.</p><p>这样设计最大好处是 <strong>rule与action相互独立且高度抽象</strong>, 运营人员与开发人员可以<strong>自由组合rule和action来达到最大灵活性与可扩展性</strong></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h4 id="Promotion"><a href="#Promotion" class="headerlink" title="Promotion"></a>Promotion</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'promotions'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'code'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'name'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;string(<span class="string">'description'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;string(<span class="string">'cover'</span>)-&gt;nullable()-&gt;comment(<span class="string">'促销封面'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'asset_url'</span>)-&gt;nullable()-&gt;comment(<span class="string">'促销详情链接'</span>)</span><br><span class="line"></span><br><span class="line">    $table-&gt;integer(<span class="string">'position'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'权重'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'type'</span>)-&gt;comment(<span class="string">'优惠卷/满减促销/品牌促销/秒杀/拼团/通用.'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;json(<span class="string">'config'</span>)-&gt;nullable()-&gt;comment(<span class="string">'配置'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;timestamp(<span class="string">'began_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'促销开始时间'</span>);</span><br><span class="line">    $table-&gt;timestamp(<span class="string">'ended_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'促销结束时间'</span>);</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line">    $table-&gt;softDeletes();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了实现良好的促销效果统计行为,所有的促销行为都应该对应promotion表中的一条记录.</p><h4 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'promotion_rules'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'promotion_id'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'type'</span>);</span><br><span class="line">    $table-&gt;json(<span class="string">'config'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line"></span><br><span class="line">    $table-&gt;index(<span class="string">'promotion_id'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常见的rule type有</p><ul><li>订单总额 order_total</li><li>订单中促销项目总额 promotion_items_total</li><li>第N笔订单  nth_order</li><li>所属分类 has_category</li><li>消费者用户组 customer_group  (白金会员组/钻石会员组 等等)</li><li>购买数量  item_quantity </li><li>等等</li></ul><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'promotion_actions'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'promotion_id'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'type'</span>);</span><br><span class="line">    $table-&gt;json(<span class="string">'config'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line"></span><br><span class="line">    $table-&gt;index(<span class="string">'promotion_id'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常见的action type有</p><ul><li>订单固定折扣 order_fixed_discount</li><li>订单百分比折扣 order_percentage_discount</li><li>订单中促销项目固定折扣 promotion_items_fixed_discount</li><li>订单中促销项目阶梯式折扣 promotion_items_ladder_discount</li><li>赠送积分 present_integral</li><li>运费百分比折扣 shipping_percentage_discount</li><li>等等</li></ul><blockquote><p>json类型的config字段的灵活应用是促销系统灵活的另一个主要原因</p><p>关于json字段的使用细项,及索引方式 可以参考  <a href="https://laravel-china.org/articles/20985" target="_blank" rel="noopener">MySQL 中 JSON 字段的使用技巧</a></p></blockquote><h4 id="PromotionVariant"><a href="#PromotionVariant" class="headerlink" title="PromotionVariant"></a>PromotionVariant</h4><p>在常见的电商平台中,一个促销活动通常不会涉及所有的商品, 尤其是类似淘宝这种B2C模式的平台,促销通常是以商家报名的形式展开的. 因此我们会有一个表来记录 有哪些变体(variant)参与了本次促销.</p><blockquote><p>变体(variant)即sku, 下文将统称为变体.</p><p>另外不以product作为参与促销的最小单位, 是为了进行更细颗粒度的控制.</p></blockquote><p>一个促销可以有多个变体参与,一个变体可以同时参与多个促销. 因此 promotion_variants 实际上是promotions表和variants表中间的一张中间表, 并且这张中间表携带了其他信息, 来看看迁移文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'promotion_variants'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    </span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'variant_id'</span>)-&gt;index();</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'promotion_id'</span>)-&gt;index();</span><br><span class="line"></span><br><span class="line">    $table-&gt;decimal(<span class="string">'discount_rate'</span>)-&gt;nullable()-&gt;comment(<span class="string">'折扣率, 值为0.3表示打7折'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'stock'</span>)-&gt;nullable()-&gt;comment(<span class="string">'促销库存'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'sold'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'销售数量'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'quantity_limit'</span>)-&gt;nullable()-&gt;comment(<span class="string">'购买数量限制'</span>);</span><br><span class="line">$table-&gt;boolean(<span class="string">'enabled'</span>)-&gt;default(<span class="number">1</span>)-&gt;comment(<span class="string">'启用'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 冗余</span></span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'product_id'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'promotion_type'</span>)-&gt;comment(<span class="string">'冗余promotion表type'</span>);</span><br><span class="line">    $table-&gt;json(<span class="string">'rest'</span>)-&gt;nullable()-&gt;comment(<span class="string">'冗余'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面便是促销系统的核心表,数据库字段可以按照实际需求进行增减和修改,特殊促销可自行添加相关表, 如优惠卷促销的coupons表, 拼团的groups表, 报名促销的promotion_sign_up表等等</p><h2 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h2><h4 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h4><p>以一次圣诞节满减促销为例,第一步的工作是创建promotion和相应的rules和actions. 我们首先会有这样3条记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// promotion</span><br><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    code: '2018-christmas',</span><br><span class="line">    name: '圣诞节满减大促',</span><br><span class="line">    type: 'full_discount',</span><br><span class="line">    description: '促销商品满100减10元',</span><br><span class="line">    cover: null,</span><br><span class="line">    asset_url: null,</span><br><span class="line">    rest: null,</span><br><span class="line">    config: null,</span><br><span class="line">    position: 0,</span><br><span class="line">    began_at: '2018-12-25 00:00:00',</span><br><span class="line">    ended_at: '2018-12-26 00:00:00'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rule</span><br><span class="line">&#123;</span><br><span class="line">    'id': 1,</span><br><span class="line">    'promotion_id': 1,</span><br><span class="line">    'type': 'promotion_items_total', // 订单中促销项总额</span><br><span class="line">    'config': &#123;</span><br><span class="line">    'amount' =&gt; 10000, // unit/分 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// action</span><br><span class="line">&#123;</span><br><span class="line">    'id': 1,</span><br><span class="line">    'promotion_id': 1,</span><br><span class="line">    'type': 'promotion_items_fixed_discount', // 订单中促销项 固定折扣</span><br><span class="line">    'config': &#123;</span><br><span class="line">    'amount' =&gt; 1000, // unit/分 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当促销创建完成后,下一步就是确定本次促销的变体了.</p><p>对于自营网站,由网站运营创建促销,挑选变体并添加到promotion_variants表中.对于B2C平台,由网站运营创建促销,商家选择变体并报名参与本次促销,运营审核后将其添加到相应的promotion_variants表中.</p><p>当促销的变体确定后. 对于有需要的促销,可以为促销设计聚合页面/详情页/宣传页/推广页,然后将相应的链接和封面添加到promotion.asset_url和promotion.cover中保存即可. </p><h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p>订单对促销的判断的逻辑的laravel伪代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取平台所有有效的促销</span></span><br><span class="line">$promotions = Promotion::active()-&gt;get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过rule过滤promotion</span></span><br><span class="line">$promotions = $promotions-&gt;filter(<span class="function"><span class="keyword">function</span> <span class="params">($promotion)</span> </span>&#123;</span><br><span class="line">    $rules = $promotion-&gt;rules</span><br><span class="line">    $order = <span class="keyword">$this</span>-&gt;getOrder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判定订单是否满足所有rule,当存在一条rule不被订单所满足,应返回false,被过滤器过滤掉</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为订单应用action.</span></span><br><span class="line">$promotion-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($promotion)</span> </span>&#123;</span><br><span class="line">    $actions = $promotion-&gt;actions;</span><br><span class="line">    $order = <span class="keyword">$this</span>-&gt;getOrder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将actions逐条应用于订单</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>特别注意:</strong> 对订单应用actions并不意味着直接修改订单中的商品单价或支付总额等. 而应有条理的记录影响订单支付金额的行为和原因. 既使用上一篇中提到的adjustment来记录  <a href="https://laravel-china.org/articles/21461" target="_blank" rel="noopener">E-commerce 中订单系统的设计</a></p></blockquote><p>关于action和rule的代码逻辑可以先来看两个interface</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Promotion</span>\<span class="title">Constructs</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Checker</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isEligible</span><span class="params">(array $configuration)</span>: <span class="title">bool</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Promotion</span>\<span class="title">Constructs</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Action</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(array $configuration)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一条rule的设计都要实现上面的 Checker接口,每一条action都要实现上面的Action接口. </p><p>以上面的圣诞满减促销的rule和action为例子,来看看具体的实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Promotion</span>\<span class="title">Checker</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有很多的通用方法 如getOrder,getPromotionOrderItems等. </span></span><br><span class="line"><span class="comment"> * 因此我创建了一个基类checker来实现interface和通用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromotionItemsTotalChecker</span> <span class="keyword">extends</span> <span class="title">Checker</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isEligible</span><span class="params">(array $configuration)</span>: <span class="title">bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getPromotionOrderItemsTotal() &gt;= $configuration[<span class="string">'amount'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意一点,一笔订单中可能存在许多变体,但通常情况是只有部分变体参加了圣诞大促.因此我们计算购物总额时应该使用order中参与了圣诞促销items</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Promotion</span>\<span class="title">Actions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Promotion</span>\<span class="title">Helpers</span>\<span class="title">CreateAdjustment</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Promotion</span>\<span class="title">Helpers</span>\<span class="title">Distribute</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromotionItemsFixedDiscountAction</span> <span class="keyword">extends</span> <span class="title">Action</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Distribute</span>, <span class="title">CreateAdjustment</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(array $configuration)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 满减的金额</span></span><br><span class="line">        $amount = $configuration[<span class="string">'amount'</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($amount === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式校验, amount如果小于订单金额时,则使用订单金额作为优惠amount</span></span><br><span class="line">        $amount = <span class="number">-1</span> * min(<span class="keyword">$this</span>-&gt;getPromotionOrderItemsTotal(), $amount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($amount === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $items = <span class="keyword">$this</span>-&gt;getPromotionOrderItems();</span><br><span class="line"></span><br><span class="line">        $itemsTotals = [];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> ($items <span class="keyword">as</span> $item) &#123;</span><br><span class="line">            $itemsTotals[] = $item-&gt;total;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 促销金额等比例分配.</span></span><br><span class="line">        $splitAmount = <span class="keyword">$this</span>-&gt;distributeAmountOfItem($itemsTotals, $reduceAmount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建adjustments</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;createUnitsAdjustment($items, <span class="keyword">$this</span>-&gt;getPromotion(), $splitAmount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>本文的主要目的是提供思路与想法, 因此没有太过具体完整的代码.</strong></p><p>未来如果有机会的话会设计一些促销系统扩展等提供参考.</p></blockquote><p>上面便是一个促销系统的流程思路,下面多提供一些demo供参考</p><h4 id="优惠卷"><a href="#优惠卷" class="headerlink" title="优惠卷"></a>优惠卷</h4><p>已一张10元代金卷为例,我们会有这样两条记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// promotion</span><br><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    code: '10-cash',</span><br><span class="line">    name: '10元代金券',</span><br><span class="line">    type: 'coupon',</span><br><span class="line">    description: '全场可用',</span><br><span class="line">    cover: null,</span><br><span class="line">    asset_url: null,</span><br><span class="line">    config: &#123;</span><br><span class="line">        type: 'cash',</span><br><span class="line">        reduce_amount: 1000, // 冗余自下面action中的config中的amount</span><br><span class="line">        stock: 10000, // 库存数量</span><br><span class="line">        sold: 0, // 已经领取的数量</span><br><span class="line">        catch_limit: 1, // 领取限制</span><br><span class="line">        date_type: 'fix_term', // 固定期限</span><br><span class="line">        fix_term: 30, // 自领取日内30天有效,</span><br><span class="line">        </span><br><span class="line">        // date_type: 'fix_time_range', 固定时间段</span><br><span class="line">        // began_at: '2018-12-23 00:00:00',</span><br><span class="line">        // ended_at: '2018-12-25 00:00:00',</span><br><span class="line">    &#125;,</span><br><span class="line">    position: 0,</span><br><span class="line">    began_at: '2018-12-25 00:00:00',</span><br><span class="line">    ended_at: '2018-12-26 00:00:00'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// action</span><br><span class="line">&#123;</span><br><span class="line">    'id': 1,</span><br><span class="line">    'promotion_id': 1,</span><br><span class="line">    'type': 'order_fixed_discount', // 订单中促销项 固定折扣</span><br><span class="line">    'config':&#123;</span><br><span class="line">       'amount' =&gt; 1000, // unit/分  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代金券通常没有使用限制,因此不需要rule.</p><p>代金券通常是全场可用, 因此action我们使用 order_fixed_discount,而不是promotion_items_fixed_discount.</p><p>对于config中的配置适用于各种优惠卷,如满减卷,运费卷等等. </p><p>对于满减卷的配置只要再为这笔促销添加一个类型为<code>promotion_items_total</code> (部分变体满减)或者<code>order_total</code>(全场满减) 的rule即可</p><p>优惠卷促销通常要创建一个 coupons表来存储用户领取的优惠卷及使用情况等</p><p>优惠卷促销本质上是将传统促销以卷的形式体现了出来,既圣诞满减促销 =&gt; 圣诞满减卷的转换.</p><h4 id="秒杀-直减-聚划算"><a href="#秒杀-直减-聚划算" class="headerlink" title="秒杀/直减/聚划算"></a>秒杀/直减/聚划算</h4><p>直减类型促销通常是已变体为单位进行高折扣的促销行为,秒杀具体要折扣多少通常不是统一设定的,不同的变体会有不同的折扣率,所以可能会有这样两条记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// promotion</span><br><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    code: 'unit-discount-1290',</span><br><span class="line">    name: '1290期直减',</span><br><span class="line">    type: 'unit_discount',</span><br><span class="line">    description: null,</span><br><span class="line">    cover: null,</span><br><span class="line">    asset_url: null,</span><br><span class="line">    config: null,</span><br><span class="line">    position: 0,</span><br><span class="line">    began_at: '2018-12-25 00:00:00',</span><br><span class="line">    ended_at: '2018-12-26 00:00:00'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promotion_variant </span><br><span class="line">&#123;</span><br><span class="line">    'id': 1,</span><br><span class="line">    'variant_id': 1,</span><br><span class="line">    'prootion_id': 1,</span><br><span class="line">    'discount_rate': 0.35,</span><br><span class="line">    'stock': 100, // 秒杀库存</span><br><span class="line">    'sold': 0,</span><br><span class="line">    'quantity_limit': 1, // 限购</span><br><span class="line">    'enabled': 1,</span><br><span class="line">    'product_id': 1,</span><br><span class="line">    'promotion_type': 'unit_discount',</span><br><span class="line">    'rest': &#123;</span><br><span class="line">        variant_name: 'xxx', // 秒杀期间变体名称</span><br><span class="line">        image: 'xxx', // 秒杀期间变体图片</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promotion_variant 由运营添加或者供应商报名得到.直减并没有相应的rule/action组合而来, 属于特殊促销.</p><p>但是在代码逻辑中依旧可以提现出这种特殊的rule和action</p><p>既<code>UnitDiscountChecker</code>来判定订单是否可以参与本次秒杀促销,</p><p>通过<code>UnitDicountAction</code>来记录相应的PromotionOrderItems的折扣信息,既下面的伪代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rule验证阶段</span></span><br><span class="line"><span class="keyword">if</span> ($promotion-&gt;type === <span class="string">'unit_discount'</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">new</span> UnitDiscountChecker)-&gt;isEligible()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用action阶段</span></span><br><span class="line"><span class="keyword">if</span> ($promotion-&gt;type === <span class="string">'unit_discount'</span>) &#123;</span><br><span class="line">    (<span class="keyword">new</span> UnitDiscountAction)-&gt;execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阶梯式满减"><a href="#阶梯式满减" class="headerlink" title="阶梯式满减"></a>阶梯式满减</h4><p>阶梯式满减属于传统满减促销的一个变种.下面是一个 满100 - 10,满150 - 20,满200 - 30的阶梯式满减的action记录.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// action</span><br><span class="line">&#123;</span><br><span class="line">    'id': 1,</span><br><span class="line">    'promotion_id': 1,</span><br><span class="line">    'type': 'promotion_items_ladder_discount',</span><br><span class="line">    'config': &#123;</span><br><span class="line">        "ladder": [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"least_amount"</span>: <span class="number">10000</span>,</span><br><span class="line">                <span class="attr">"reduce_amount"</span>: <span class="number">1000</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                "least_amount": 15000, </span><br><span class="line">                "reduce_amount": 2000</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                "least_amount": 20000, </span><br><span class="line">                "reduce_amount": 3000</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的ladder应该由运营人员后台设定,实际上对于每一种action和rule的type,在后台管理界面中都应该设置其相应的表单交互</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>如果你有疑惑或者更多的想法欢迎留言.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电商平台中,促销是必不可少的营销手段,尤其在国内 各种玩法层出不穷,最开始的满减/秒杀 到优惠卷 再到 拼团/砍价等等&lt;/p&gt;
&lt;p&gt;一个良好的促销系统应该具备易于扩展,易于统计促销效果等特点,在遇到秒杀类促销时还需要做到可扩容,抗并发(本次不考虑秒杀系统的设计)等等.  废话说完了,进入正题吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="e-commerce promotion laravel" scheme="http://beian.miit.gov.cn/tags/e-commerce-promotion-laravel/"/>
    
  </entry>
  
  <entry>
    <title>E-commerce 中订单系统的设计</title>
    <link href="http://beian.miit.gov.cn/posts/design-of-order-system-in-e-commerce.html"/>
    <id>http://beian.miit.gov.cn/posts/design-of-order-system-in-e-commerce.html</id>
    <published>2018-12-22T10:28:10.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h4 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h4><p>订单系统的核心表自然是 <strong>orders</strong>系列表,laravel的迁移文件如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'orders'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'number'</span>)-&gt;nullable()-&gt;comment(<span class="string">'订单号'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'address_id'</span>)-&gt;nullable()-&gt;comment(<span class="string">'订单地址'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'user_id'</span>)-&gt;index()-&gt;comment(<span class="string">'用户id'</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'items_total'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'order每一个item的total的和 unit/分'</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'adjustments_total'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'调整金额 unit/分'</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'total'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'需支付金额 unit/分'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'local_code'</span>)-&gt;comment(<span class="string">'语言编号'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'currency_code'</span>)-&gt;comment(<span class="string">'货币编号'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'state'</span>)-&gt;comment(<span class="string">'主状态 checkout/new/cancelled/fulfilled'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'payment_state'</span>)-&gt;comment(<span class="string">'支付状态 checkout/awaiting_payment/partially_paid/cancelled/paid/partially_refunded/refunded'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'shipment_state'</span>)-&gt;comment(<span class="string">'运输状态 checkout/ready/cancelled/partially_shipped/shipped'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;ipAddress(<span class="string">'user_ip'</span>)-&gt;comment(<span class="string">'用户ip ip2long后的结果'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;timestamp(<span class="string">'paid_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'支付时间'</span>);</span><br><span class="line">    $table-&gt;timestamp(<span class="string">'confirmed_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'确认订单时间'</span>);</span><br><span class="line">    $table-&gt;timestamp(<span class="string">'reviewed_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'评论时间'</span>);</span><br><span class="line">    $table-&gt;timestamp(<span class="string">'fulfilled_at'</span>)-&gt;nullable()-&gt;comment(<span class="string">'订单完成时间'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;json(<span class="string">'rest'</span>)-&gt;nullable()-&gt;comment(<span class="string">'非核心字段冗余'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来是<strong>order_items</strong>表,用于记录order的item</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'order_items'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_id'</span>)-&gt;index()-&gt;comment(<span class="string">'外键'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'variant_id'</span>)-&gt;comment(<span class="string">'variant是国外的称呼,国内通常称为sku. 既库存最小单位'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'product_id'</span>)-&gt;comment(<span class="string">'冗余字段'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'quantity'</span>)-&gt;comment(<span class="string">'购买数量'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjustment calculate</span></span><br><span class="line">    $table-&gt;integer(<span class="string">'units_total'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'item中每一个unit的和. 单位/分'</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'adjustments_total'</span>)-&gt;default(<span class="number">0</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'total'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'units_total + adjustments_total'</span>);</span><br><span class="line">    $table-&gt;integer(<span class="string">'unit_price'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'variant单价,冗余字段'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;json(<span class="string">'rest'</span>)-&gt;nullable()-&gt;comment(<span class="string">'非核心字段冗余'</span>);</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>做过海外电商或者亚马逊的朋友应该对variant(变体)不陌生. 国内称为sku. 每一个商品都会有多个变体</p></blockquote><p>接下来是<strong>order_item_units</strong> 表</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'order_item_units'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'item_id'</span>)-&gt;index();</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'shipment_id'</span>)-&gt;comment();</span><br><span class="line">    $table-&gt;integer(<span class="string">'adjustments_total'</span>)-&gt;default(<span class="number">0</span>);</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于用户购买的每一件实体,我们都需要谨慎的做一条记录,其会涉及到运输/促销/退货等问题, 例如variantA我们购买了三件,那么我们就需要为这三件相同的变体分别创建三条记录.</p><p>上面三张表的关系从上往下 一个order会有多个item,一个item根据quantity的值,会有对应数量的unit. </p><blockquote><p> order和order_item表大家应该都知道. </p><p>order_item_units表可能有些同学第一次知道,但是其是必要存在的</p></blockquote><p><em>tip: 所有的价格字段都使用分为单位存储,从而避免小数在计算机系统中存在的一些问题</em></p><p>可以消化梳理一下上面的三张订单系统核心表,然后再介绍一下其他相关表的设计. 数据库的设计应该是灵活的,可以根据实际的需求任意添加和修改字段</p><h4 id="Adjustment"><a href="#Adjustment" class="headerlink" title="Adjustment"></a>Adjustment</h4><p>上面三张表都出现了adjustment_total字段,可能会有些疑惑.</p><p>如果我们每个变体的价格是10元,那我买三个这件变体则需要30元,但是实际支付的金额往往都不是30元.,会有各种各样的情况影响我们最终支付的价格.</p><p>比如运费+5元,促销折扣 -8元,税收+3元,退还服务 +0.5元,最后实际需要支付 35.5元.  为什么30元的金额最后却支付了35.5元?</p><p>我们不能凭空蹦出个35.5元,影响商品实际支付金额的每一个因素都是至关重要,我们需要负责任的记录下来.这便是adjustment表的来源.</p><p>首先看看迁移文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'adjustments'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_id'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_item_id'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_item_unit_id'</span>)-&gt;nullable();</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'type'</span>)-&gt;comment(<span class="string">'调整的类型 shipping/promotion/tax等等'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'label'</span>)-&gt;comment(<span class="string">'结合type决定'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;string(<span class="string">'origin_code'</span>)-&gt;comment(<span class="string">'结合label决定'</span>);</span><br><span class="line"></span><br><span class="line">    $table-&gt;bool(<span class="string">'included'</span>)-&gt;comment(<span class="string">'是否会影响最终订单需要支付的价格'</span>)</span><br><span class="line">        $table-&gt;integer(<span class="string">'amount'</span>);</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line"></span><br><span class="line">    $table-&gt;index(<span class="string">'order_id'</span>);</span><br><span class="line">    $table-&gt;index(<span class="string">'order_item_id'</span>);</span><br><span class="line">    $table-&gt;index(<span class="string">'order_item_unit_id'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调整对订单价格的影响分为三种类型, 分别是 影响整个order, 影响order_item(较少预见),影响order_item_units. </p><blockquote><p>included字段 用来判断本条adjustment记录,是否会影响消费者最终需要支付的金额</p><p>大部分的adjustment都会影响最终结算的价格, 小部分如商品税,通常已经计算在了商品的单价中, 不会影响消费者最终需要支付的金额.但是在开具发票时 却需要展示,因为我们做必要的记录</p></blockquote><p>举个例子, 假设我们一笔订单的运费是5元,那么会有这样一条adjustment记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    order_id: 1,</span><br><span class="line">    order_item_id: null,</span><br><span class="line">    order_item_unit_id: null,</span><br><span class="line">    amount: 500,</span><br><span class="line">    type: 'shipping',</span><br><span class="line">    label: 'UPS',</span><br><span class="line">    origin_code: null,</span><br><span class="line">    included: 1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们消费者在一个订单中购买了三条1.5米数据线,并使用了一张8元的代金券,那么会有这样三条adjustment记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        order_id: null,</span><br><span class="line">        order_item_id: null,</span><br><span class="line">        order_item_unit_id: 1,</span><br><span class="line">        amount: -267,</span><br><span class="line">        type: 'promotion',</span><br><span class="line">        label: '8元代金券',</span><br><span class="line">        origin_code: 'KSDI12K2', // 代金券code</span><br><span class="line">        included: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        order_id: null,</span><br><span class="line">        order_item_id: null,</span><br><span class="line">        order_item_unit_id: 2,</span><br><span class="line">        amount: -267,</span><br><span class="line">        type: 'promotion',</span><br><span class="line">        label: '8元代金券',</span><br><span class="line">        origin_code: 'KSDI12K2', // 代金券code</span><br><span class="line">        included: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        order_id: null,</span><br><span class="line">        order_item_id: null,</span><br><span class="line">        order_item_unit_id: 3,</span><br><span class="line">        amount: -266,</span><br><span class="line">        type: 'promotion',</span><br><span class="line">        label: '8元代金券',</span><br><span class="line">        origin_code: 'KSDI12K2', // 代金券code</span><br><span class="line">        included: 1</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>实际上对于大部分的促销需求 我们都应该将促销的折扣金额均分到每一个unit中.</p><p>这样设计的一个好处是,当消费者退调用其中一根数据线时,我们可以很清楚的计算出应该退多少金额给消费者. 既 <code>单价 + order_item_unit.adjustment</code></p><p>实际上清楚的记录每一笔影响最终支付金额的adjustment,无论对消费者还是对供应商来说都是负责的做法.</p><blockquote><p> 运费为什么不需要分摊到unit?</p><p>运费对于一笔订单来说,是固定的外部消费(由快递公司获利),退款时商家并不需要为运费负责, 只需要退还商品的等额价值即可</p><p>更加白话的说法就是 你在淘宝买了一个商品20元,运费10元, 你觉得商品不好想要退货(不考虑寄回的运费), 商家需要退你30元吗?</p></blockquote><h4 id="Shipment-Payment"><a href="#Shipment-Payment" class="headerlink" title="Shipment/Payment"></a>Shipment/Payment</h4><p>shipment为订单的运输信息存储,payment为支付信息存储.先来看看迁移文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'shipments'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'method_id'</span>)-&gt;comment(<span class="string">'运输方式 外键'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_id'</span>)-&gt;comment(<span class="string">'订单 外键'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'state'</span>)-&gt;comment(<span class="string">'运输状态'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'tracking_number'</span>)-&gt;nullable()-&gt;comment(<span class="string">'订单号码'</span>);</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line"></span><br><span class="line">    $table-&gt;index(<span class="string">'order_id'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Schema::create(<span class="string">'payments'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">    $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'method_id'</span>)-&gt;comment(<span class="string">'支付方式'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'order_id'</span>);<span class="number">7</span></span><br><span class="line">    $table-&gt;string(<span class="string">'currency_code'</span>, <span class="number">3</span>)-&gt;comment(<span class="string">'冗余 货币编码'</span>);</span><br><span class="line">    $table-&gt;unsignedInteger(<span class="string">'amount'</span>)-&gt;default(<span class="number">0</span>)-&gt;comment(<span class="string">'支付金额'</span>);</span><br><span class="line">    $table-&gt;string(<span class="string">'state'</span>);</span><br><span class="line">    $table-&gt;text(<span class="string">'details'</span>)-&gt;nullable();</span><br><span class="line">    $table-&gt;timestamps();</span><br><span class="line"></span><br><span class="line">    $table-&gt;index(<span class="string">'order_id'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面在order_item_units表中存在一个shipment_id 就对应这里的shipment表. shipment和order_item_units之间是<strong>一对多</strong>的关系,订单中的每一个实体都可以被分别运输,例如京东购物时经常会见到这种情况. </p><p><strong>一条shipment/payment 会和一条实际存在的货运记录/支付记录(退款记录) 挂钩.</strong></p><p>上面就是订单系统的核心表了,对于后端来说,数据库就已经可以反映出整个系统的设计了.</p><p>接下来抽出一些细节进行详细的介绍</p><h2 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h2><h4 id="状态的设计"><a href="#状态的设计" class="headerlink" title="状态的设计"></a>状态的设计</h4><p>相信很多小伙伴在做订单系统时会被各种状态 待确认,待支付,待发货,已发货,关闭订单 等等弄的晕头转向,今天我们就来梳理一下订单系统中的各种状态</p><p>如果各种状态只在order表使用一个state字段来记录显得有些力不从心,因此推荐使用三个字段,它们分别是 <strong>state,shipment_state,payment_state.</strong> 来分别记录在订单中我们或者消费者最关心的三种状态. </p><p>先来分别看看三个state的状态转移图</p><p><strong>order.state↓</strong></p><p><img src="http://asset.eienao.com/18-12-22/78777487.jpg" alt></p><p>这是一笔订单的几个最基本的几个状态. </p><p>先讲一讲初始状态,既 checkout, 这与订单在什么时候创建有关系,当消费者在购物车点击结账时,就创建了一个订单,用于本次结账, 因此订单的初始状态为checkout</p><blockquote><p>结账也就是所谓的确认订单页,在该页面中,消费者可以选择优惠券,选择地址等操作</p></blockquote><p>处于该状态的订单对于后台管理系统/用户个人中心都是不可见的,且checkout类型订单的创建,也不会是库存有任何的变化</p><p>当用户在结账界面操作完成后需要用户点击确认订单. 既行为 <strong>confirm</strong>的触发,使订单的状态从checkout转换成了new. 此时的订单无论是对于消费者/运营人员/仓储系统来说,都是真实存在且有效的. 且响应的购物车记录也被清空. 对于一笔状态为new的订单,消费者可以对其行使付款的权利. </p><p><strong>order.payment_state↓</strong></p><p><img src="http://asset.eienao.com/18-12-22/4209529.jpg" alt></p><p>payment的初始状态为checkout与上述一致.</p><p>当消费者触发confirm后, 我们就可以触发request_payment行为,将订单的付款状态转换为 await_payment, 且将消费者引导到支付界面, 当消费者支付成功后,在支付成功的回调中,触发pay行为,将支付状态转换为paid.</p><p>关于退款的状态如上图所示,需要注意的是,对于退款,会出现只需要退订单中的部分商品的情况,因此加入了 partially_refunded(部分退款的状态). </p><p><strong>order.shipment_state↓</strong></p><p><img src="http://asset.eienao.com/18-12-22/15354759.jpg" alt></p><p>当消费者confirm后, 我们同时也需要调用响应的request_shipment,将我们的运输状态设置为一个ready状态,此时库存已经锁定.</p><blockquote><p>关于仓库具体的备货时机 是在用户确认订单之后,还是等用户支付完成之后,需要根据实际的产品需求确定.</p><p>上面的状态图属于前者,当消费者确认订单后,便锁定了库存,并开始了备货阶段.如果是后一种情况可以将checkout修改为pending,等待消费者付款完成后再将状态转移到ready</p></blockquote><p><strong>对于上面繁杂的状态转换,可以手动处理,也可以选择使用<a href="https://github.com/weiwenhao/state-machine" target="_blank" rel="noopener">state-machine</a> 进行处理</strong></p><h4 id="订单价格的计算"><a href="#订单价格的计算" class="headerlink" title="订单价格的计算"></a>订单价格的计算</h4><p>单价作为一件商品的固有属性,不会受到运输/促销折扣等等因素的影响. 当商家对一个价值100元商品进行一个30%的折扣时,消费者只需要用70元的价格买入, 但实际上商品的单价依旧是100元.</p><p>当一笔订单不存在任何的adjustment时,我们可以很容易的计算出订单的实际支付价格, 只需要把各个order_item的unit_price * quantity 相加起来即可</p><p>但是有了adjustment参与之后,我们必须自下往上的计算. 下面的例子是在laravel项目且使用了上述的数据库设计后的一个计算方法.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">calculator</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $items = $order-&gt;items;</span><br><span class="line">    $items-&gt;load(<span class="string">'adjustments'</span>, <span class="string">'units.adjustments'</span>);</span><br><span class="line">    $order-&gt;load(<span class="string">'adjustments'</span>);</span><br><span class="line"></span><br><span class="line">    $items-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($item)</span> </span>&#123;</span><br><span class="line">        $item-&gt;units-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($unit)</span> </span>&#123;</span><br><span class="line">            $unit-&gt;adjustments_total = $unit-&gt;adjustments-&gt;sum(<span class="string">'amount'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $item-&gt;units()-&gt;saveMany($item-&gt;units);</span><br><span class="line"></span><br><span class="line">        $item-&gt;adjustments_total = $item-&gt;adjustments-&gt;sum(<span class="string">'amount'</span>);</span><br><span class="line"></span><br><span class="line">        $item-&gt;units_total = $item-&gt;quantity * $item-&gt;unit_price + $item-&gt;units-&gt;sum(<span class="string">'adjustments_total'</span>);</span><br><span class="line"></span><br><span class="line">        $item-&gt;total = $item-&gt;units_total + $item-&gt;adjustments_total;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $order-&gt;items()-&gt;saveMany($items);</span><br><span class="line"></span><br><span class="line">    $order-&gt;adjustments_total = $order-&gt;adjustments-&gt;sum(<span class="string">'amount'</span>);</span><br><span class="line">    $order-&gt;items_total = $order-&gt;items-&gt;sum(<span class="string">'total'</span>);</span><br><span class="line">    $order-&gt;total = $order-&gt;items_total + $order-&gt;adjustments_total;</span><br><span class="line">    $order-&gt;save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol><li><p>当订单创建的同时(结账阶段)就分别创建了一条payment/和shipment记录.在payment和shipment中分别记录了用户选择的支付方式与运输方式.</p><p>在电商系统中,通常会有多种多样的支付方式和运输方式.</p><p>但是在实际的业务编写时,业务层并不希望关心和处理繁杂的支付与运输方式,此时支付网关和运输网关便应运而生,其对业务层隐藏了繁杂的细节,而暴露出了统一的api接口.</p><p>支付网关如提供商业服务的 ping++,当然也有一些开源项目对这方面有所支持. 如 <a href="https://github.com/yansongda/pay" target="_blank" rel="noopener">yansongda/pay</a> , <a href="https://github.com/Payum/Payum" target="_blank" rel="noopener">Payum/Payum</a>等等</p></li><li><p>对于确认了但超过一定时间没有付款的订单,我们可以选择主动关闭该订单. 将order.state/order.payment_state/order.shipment_state 设置为cancelled,并对库存进行归还等系列操作</p></li></ol><p>下一篇将会介绍促销系统的设计与实现,本篇的主要目的是介绍订单系统的相关设计,为下一篇做一个铺垫. </p><p>由于篇幅有限并没有过多的细节,有疑问或者不妥的地方欢迎留言.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;数据库设计&quot;&gt;&lt;a href=&quot;#数据库设计&quot; class=&quot;headerlink&quot; title=&quot;数据库设计&quot;&gt;&lt;/a&gt;数据库设计&lt;/h2&gt;&lt;h4 id=&quot;Order&quot;&gt;&lt;a href=&quot;#Order&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="e-commerce order laravel" scheme="http://beian.miit.gov.cn/tags/e-commerce-order-laravel/"/>
    
  </entry>
  
  <entry>
    <title>Vue 工程化最佳实践</title>
    <link href="http://beian.miit.gov.cn/posts/vue-engineering-best-practices.html"/>
    <id>http://beian.miit.gov.cn/posts/vue-engineering-best-practices.html</id>
    <published>2018-12-14T03:49:27.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>总览</p><p><img src="http://asset.eienao.com/20181214113352.png" alt></p><ul><li><p>api目录用于存放 api请求,文件名与模型名称基本一致,文件名使用小驼峰, 方法名称与后端restful控制器一致.</p><ul><li><img src="http://asset.eienao.com/20181214113459.png" alt></li></ul></li><li><p>enums 目录存放 常量, 与后端的常量目录对应</p><ul><li><img src="http://asset.eienao.com/20181214113531.png" alt></li></ul></li><li><p>icons目录用于存放图标, element-ui提供的图标实在是太少啦.所以我通常会使用 阿里的iconfont</p></li><li>lang目录存放多语言</li><li>layouts目录存放布局<ul><li><img src="http://asset.eienao.com/20181214114528.png" alt></li><li>上面展示的是一个后台系统, empty为一个空布局.用于登录页面, 其他页面则使用default布局. 布局不需要过多介绍,写过laravel blade都很熟悉了.这里的布局需要和vue-router配合使用</li></ul></li><li>mixins 类似php的trait, 但是它更强大, 完整贴合vue组件的生命周期</li><li><p>plugins 目录存放插件配置, 比如 axios,vue-lazy等 (这是从nuxt中学到的概念)</p><ul><li><img src="http://asset.eienao.com/20181214114547.png" alt></li></ul></li><li><p>router目录存放与 前端路由相关的配置,总体来说类似于laravel的api层</p></li><li><p>store 目录即vuex的目录, 类似于前端的model. 其文件与后端model相匹配,采用小驼峰命名</p><ul><li><img src="http://asset.eienao.com/20181214114609.png" alt></li></ul></li><li><p>utils 目录存放辅助函数</p></li><li>views 为业务视图层,相信后端同学也很熟悉.其由vue-router直接调度</li><li>main.js 为app的入口, 类似于后端的index.php</li><li>components 目录, 存放组件.通常是一些可复用的组件会单独存放在该目录</li></ul><p>总体来说, 已后端的mvc思想来看现代的前端项目是非常的自然的. 后端的model对应前端的store, 后端的router对应前端的router,后端的controller + views 对应前端的views.</p><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><p> 就目前来说 vue项目很少用到 class, 因此 .js文件通常都是一个 module, 所以文件名使用小驼峰的形式命名. 如果有类文件,则类文件使用大驼峰的形式命名.</p><p>.vue文件 可以使用 中划线和大驼峰两种命名方式, 参考了element/iview/nuxt项目之后, 推荐统一使用中划线命名.</p><p>所有的文件夹名称统一使用中划线命名</p><blockquote><p>引入vue组件时文件时需要转换成大驼峰<code>import &#39;TestTest&#39; from &#39;@/components/test-test&#39;</code></p><p>在template 使用时依旧使用中划线</p><p><code>&lt;test-test /&gt;</code></p></blockquote><p>其他规范如变量命名和使用规范 使用eslint的standard 即可很好的解决.</p><p>前端存在很多的事件 如change/input/upload/sumit等等,相应的处理推荐使用 handle + 事件名称, 如<code>handleChange</code></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>vue-router 解析当前用户键入的 url, 然后匹配合适的视图组件加载. </p><p>着重介绍一下 我对views目录下的视图组件的理解,已修改地址为例</p><p><img src="http://asset.eienao.com/20181214114635.png" alt></p><p>script部分既控制器部分,其请求数据, 然后注入到view 中, 就像后端的mvc一样.只不过vue将 vc 其写入到了一个文件中.这样理解对于写过后端的同学显得更加的自然</p><h5 id="控制器如何获取数据"><a href="#控制器如何获取数据" class="headerlink" title="控制器如何获取数据?"></a>控制器如何获取数据?</h5><p>在过去的vue项目中,我们可能会见到这样的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... views/address/edit.vue</span></span><br><span class="line">created () &#123;</span><br><span class="line">    axios.get(<span class="string">'/addresses/1'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.list = resposne.data              </span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这种写法无异于后端在控制器中写sql语句一样,在工程化实践中不推荐这么做,后端通过model来获取数据会更加的优雅自然.在vue项目中, model既vuex,因此推荐这么做</p><blockquote><p>如果你对我说的东西一脸懵逼, 那么你可以看一下 vuex的文档. 我现在做的就是用后端熟悉的概念,来描述前端项目的最佳实践</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... views/address/edit.vue 控制器+视图</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    address: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.$store.address.itemBy[<span class="number">1</span>] <span class="comment">// 从store模型中取出我们想要数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... store/modules/address.js  数据源</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        itemBy: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h5 id="store中的数据从哪里来"><a href="#store中的数据从哪里来" class="headerlink" title="store中的数据从哪里来?"></a>store中的数据从哪里来?</h5><p>数据当然是从后端的数据库中获取,我们不能让前端直接访问我们的数据库,因此我们会提供api让前端访问.store中存在一个发起api请求的地方,既 action.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... store/modules/address.js  模型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        itemBy: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="keyword">async</span> fetchItem(&#123; commit, state &#125;, &#123; id &#125;) &#123;</span><br><span class="line">             <span class="comment">// 对axios和api进行了简单的封装,使api请求更加语义化</span></span><br><span class="line">            cosnt &#123; data &#125; = <span class="keyword">await</span> address.show(id)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// action只能通过提交commit来修改state,具体原因请查看vuex文档 (其实我也忘了为啥 (╯﹏╰))</span></span><br><span class="line">            commit(<span class="string">'SET_ITEM'</span>, data) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        SET_ITEM: <span class="function">(<span class="params">state, item</span>) =&gt;</span> &#123;</span><br><span class="line">            state.itemBy[item.id] = item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这样我们的模型中就有数据啦</p><h5 id="什么时候去调用fetchItem去请求后端呢"><a href="#什么时候去调用fetchItem去请求后端呢" class="headerlink" title="什么时候去调用fetchItem去请求后端呢?"></a>什么时候去调用<code>fetchItem</code>去请求后端呢?</h5><blockquote><p><a href="https://router.vuejs.org/zh/guide/advanced/data-fetching.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/data-fetching.html</a> vue-router文档的解答</p></blockquote><p>这里不推荐在vue原始的生命周期中去调用初始化请求,可能会带来 数据还没有获取到,template却已经被渲染.会造成一些数据不存在的异常,推荐在vue-router的生命周期中去请求数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... views/address/edit.vue</span></span><br><span class="line"><span class="keyword">async</span> beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 等待模型数据加载完毕,才继续进行vue组件的生命周期</span></span><br><span class="line">    <span class="keyword">await</span> store.dispatch(<span class="string">'fetchItem'</span>, to.params.id) </span><br><span class="line">    </span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="comment">// 不推荐在这里调用 fetchItem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>到这里你可能发现,这和你平时写的vue有些不一样, 没有类似 <code>this.data = response.data</code> 这种操作. 类似这种操作其实类似赋值操作,或者称为副作用,其引入了时间的概念,使数据的管理变的复杂. 直观的体现就是我们可能会有这种多余的 <code>if(data)</code>判断.</p><p>当然副作用是难以避免的,但是我们可以统一的管理他们.类似上面的代码就是一套我觉得还不错的方法.从view的角度看, 数据是固有存在存在的,其不需要关心是否是否已经被加载完毕,且store中的不可被view修改,既数据只能单向流动</p><p>在store中统一管理数据的另外一个好处就是方便持久化</p><h5 id="view层如何修改数据源"><a href="#view层如何修改数据源" class="headerlink" title="view层如何修改数据源?"></a>view层如何修改数据源?</h5><p>上面的描述实际上表达了一种 发布与订阅的模式, 从store到view的数据流是严格单向数据流动.</p><p>view层不允许直接修改store中的数据,但是view层却可以通过发送action来影响数据源. </p><p>比如初始化时的dispatch的action,各种event触发的dispatch. 当数据源发生改变时,作为订阅者的view层会非常自然的重新渲染.</p><blockquote><p>这种设计和父子组件类似,vue中子组件不允许直接修改父组件props到子组件的数据,只能通过向父组件emit event. 在view和store之间,这种设计依然合理.</p><p>这也意味着应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。</p></blockquote><p><img src="http://asset.eienao.com/20181214114653.png" alt></p><p>上面的图很好的阐述了这种开发模式.  引自 <a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="noopener">https://github.com/sorrycc/blog/issues/1</a></p><h3 id="view层再深入"><a href="#view层再深入" class="headerlink" title="view层再深入"></a>view层再深入</h3><p>view层的script部分,除了充当了传统的controller,起到初始化的作用外,实际上还做了更多的事情. </p><p>先从data部分说起,在view层会有一些状态需要记录, 如 菜单的展开或收起, 弹窗的弹出与关闭. 对于这样的状态的管理,一种做法就是将存储在data部分.</p><blockquote><p>也有人将所有的状态 也放在 store中的state维护. 既state分为状态和数据 两种类型.</p></blockquote><p>view层的script更重要的部分,是其到了一个交互反馈的作用, 既类似下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click=&quot;handleSubmit&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleSubmit() &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于css部分,由于个人不了解css,也不清楚css的业界规范及在vue上的最佳实践,因此不做过多介绍.</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>在前面的介绍中, store和api 目录是和数据挂钩的,当数据库定下来,这一部分也就定了下来.</p><p> views/components 和业务(ui)挂钩,需要等设计稿确定后,这一部分才能确定下来.</p><blockquote><p>PS设计稿的图层通常就是组件的拆分规范 ?<br>使用vuex存储数据的另一个好处就是可以无缝的切换到ssr框架nuxt</p></blockquote><p>views和store之间是一种订阅和发布的模式.</p><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p><strong>store中的state应该如何组织?</strong> 对于api请求,我们经常会看到这样的json数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// post</span><br><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    title: xxxx,</span><br><span class="line">    content: xxxx,</span><br><span class="line">    user: &#123;</span><br><span class="line">        id: xxx,</span><br><span class="line">        nickname: xxx,</span><br><span class="line">        avatar: xxx,</span><br><span class="line">    &#125;,</span><br><span class="line">    comments: [</span><br><span class="line">        &#123;</span><br><span class="line">            id: xxx,</span><br><span class="line">            user_id: xxx,</span><br><span class="line">            content: xxx,</span><br><span class="line">            user: &#123;</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            //....</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的数据结构复杂,嵌套深入.  如果我们将他们一股脑的存在 post的state中,会造成数据过于集中,冗余. comments无法独立化更新等等问题.  使得前端 scheme/orm,数据组织的规范化变的迫切需要</p><p>但是vue在这方面没有很好的规范和最佳实践. react在这方面比较不错的实践 <a href="https://github.com/paularmstrong/normalizr" target="_blank" rel="noopener">https://github.com/paularmstrong/normalizr</a></p><p><strong>如何设计良好规范的compoents?</strong> </p><p>组件的设计在业务层非常的重要,在下一篇我会介绍一下我总结出的一些实践</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h3&gt;&lt;p&gt;总览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://asset.eienao.com/
      
    
    </summary>
    
    
      <category term="vue" scheme="http://beian.miit.gov.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中 JSON 字段的使用技巧</title>
    <link href="http://beian.miit.gov.cn/posts/tips-for-using-json-fields-in-mysql.html"/>
    <id>http://beian.miit.gov.cn/posts/tips-for-using-json-fields-in-mysql.html</id>
    <published>2018-12-12T03:13:40.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>mysql5.7.8之后开始原生支持json. 在类似mongodb这种nosql数据库中,json存储数据是非常自然的, 在mysql中合理的使用json,能够带来极大的便利</p><a id="more"></a><h4 id="Json字段的使用场景"><a href="#Json字段的使用场景" class="headerlink" title="Json字段的使用场景"></a>Json字段的使用场景</h4><p>在读laravel手册举例子时,我们经常会看到 <code>$user-&gt;is_admin</code> 来判断用户是否为管理员,但是在用户表中,admin往往只占很小一部分.如果单开一个is_admin字段是很没有必要的行为.数据库中会有大量的无意义数据存储, 我们可以为user表创建一个 json 字段,来存储我们的is_admin字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        username: 'weiwenhao',</span><br><span class="line">        rest: &#123; // 冗余字段</span><br><span class="line">            is_admin: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        username: 'eienao',</span><br><span class="line">        rest: null</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当然即使不使用json,我们也不会使用is_admin来判断是否为管理员.</p><p>可以通过新增admin表或者RABC来标志管理员</p></blockquote><p>依旧是用户表, 很常见的一个需求是第三方登录,如果我们使直接在user表新增<code>facebook_id,facebook_email,facebook_phone_number,google_id,....</code>字段, 可以预见这会造成大量的无意义数据(即使他们不占用内存,或者影响性能)</p><blockquote><p>一种解决办法是 使用一对多关系来解决, 既建立一个 第三方登录表来存储第三方登录的id/email/phone_number等</p></blockquote><p>但是我更喜欢使用json字段来解决这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        username: &apos;weiwenhao&apos;,</span><br><span class="line">        rest: &#123;</span><br><span class="line">            is_admin: 1,</span><br><span class="line">            facebook_id: 2348234,</span><br><span class="line">            facebook_phone_number: 2834723234,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        username: &apos;eienao&apos;,</span><br><span class="line">        rest: &#123;</span><br><span class="line">            google_id: 2348234,</span><br><span class="line">            google_email: xxx@gmail.com</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看出,使用json字段使数据表的设计更加自然,集中,业务也相应的更加的简单方便.</p><h4 id="Json字段在laravel中的使用"><a href="#Json字段在laravel中的使用" class="headerlink" title="Json字段在laravel中的使用"></a>Json字段在laravel中的使用</h4><p>首先是迁移文件 <code>$table-&gt;json(&#39;rest&#39;)-&gt;nullable();</code> </p><p>laravel对json的使用进行了一定的优化,对于更新和创建我们可以.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$user = <span class="keyword">new</span> User;</span><br><span class="line">$user-&gt;&#123;<span class="string">'rest-&gt;google_id'</span>&#125; = <span class="string">'xxx'</span>; </span><br><span class="line"><span class="comment"># 如果你的rest字段为null,那么上面的操作会使 null 会变成 &#123;google_id: "xxx"&#125;, 不需要再做 是否为null的判定啦</span></span><br><span class="line"><span class="comment"># 如果仅使用上面的插入操作,也不需要在使用模型的修改器来吧 json =&gt; array, array =&gt; json啦</span></span><br></pre></td></tr></table></figure><blockquote><p>当rest字段的值为null时,批量操作无法执行, 类似  <code>update([&#39;rest-&gt;google_id&#39; =&gt; &#39;xxx&#39;])</code> 这样的操作执行无效,因此更推荐上面的方式来进行更新操作</p></blockquote><p>对于查找操作可以方便的使用</p><p><code>User::where(&#39;rest-&gt;google_id&#39;,&#39;xxx&#39;)-&gt;firstOrFail()</code></p><blockquote><p> 关于检索的效率问题,在后面内容中给出解决方案</p></blockquote><h4 id="Generated-Column-生成列"><a href="#Generated-Column-生成列" class="headerlink" title="Generated Column (生成列)"></a>Generated Column (生成列)</h4><p>5.7新增了生成列, 生成列的值是根据列定义中包含的表达式计算得来.官方示例:计算直角三角形的斜边的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle (</span><br><span class="line">  sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) # <span class="keyword">AS</span> (expression) 为生成列的核心语法</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> triangle (sidea, sideb) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"># 对于上面的插入,查询可以得到如下结果</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM triangle;</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br><span class="line">| sidea | sideb | sidec              |</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br><span class="line">|     1 |     1 | 1.4142135623730951 |</span><br><span class="line">|     3 |     4 |                  5 |</span><br><span class="line">|     6 |     8 |                 10 |</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br></pre></td></tr></table></figure><p>上面的 sidec的值 是根据sidea和sideb计算得来, 并未实际的存储在磁盘中.mysql5.7之前我们想要实现上面的需求可能会这样写sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,(<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) <span class="keyword">as</span> sidec <span class="keyword">FROM</span> triangle;</span><br></pre></td></tr></table></figure><p>上面既生成列的主要作用, 实际上生成列有两种子类型,上面的例子属于 virtual (虚拟) 类型的生成列, 其并没有将sidec的值实际存储在磁盘中.</p><p>除了virtual, 生成列还支持 stored类型,其创建语句为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#...</span><br><span class="line">sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb)) STORED # stored不指定则默认为 virtual</span><br><span class="line">#...</span><br></pre></td></tr></table></figure><p>当行创建或者更新时, 会重新计算 sidec并将其存储在磁盘中</p><p>生成列的另一个重要的特性是可以根据<strong>生成列表达式的计算结果建立索引</strong>. 其建立索引的方式和普通字段创建索引的方式一致.1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle (</span><br><span class="line">  sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) # <span class="keyword">AS</span> (expression) 为生成列的核心语法</span><br><span class="line">  <span class="keyword">INDEX</span>(<span class="string">`sidec`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>索引本身也是存储在磁盘中的实际存在的物质, 因此 virtual 生成列 + 索引,可以达到存储空间的最有效利用. </p><blockquote><p>对于stored 生成列 + 索引, 通常不会访问到存储在磁盘中stored 生成列,而是直接访问索引.因此没有必要使用stored生成列</p></blockquote><h4 id="使用生成列为json中的字段添加索引"><a href="#使用生成列为json中的字段添加索引" class="headerlink" title="使用生成列为json中的字段添加索引"></a>使用生成列为json中的字段添加索引</h4><p>已user表的rest.google_id为例,建表操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#...</span><br><span class="line">`rest` json NULL,</span><br><span class="line"></span><br><span class="line"># JSON_EXTRACT(`rest`,'$.google_id') 等价于 `rest`-&gt;'$.google_id'</span><br><span class="line"># 5.7.13版本后 </span><br><span class="line"># JSON_UNQUOTE(JSON_EXTRACT(`rest`,'$.google_id')) 等价于 `rest`-&gt;&gt;'$.google_id'</span><br><span class="line"># 使用生成列为json添加索引时,请务必使用 JSON_UNQUOTE(JSON_EXTRACT(`rest`,'$.google_id'))/-&gt;&gt;</span><br><span class="line">`google_id` varchar GENERATED ALWAYS AS (`rest`-&gt;&gt;'$.google_id')) NULL</span><br><span class="line"></span><br><span class="line">UNIQUE INDEX(`google_id`)</span><br><span class="line">#...</span><br></pre></td></tr></table></figure><p>在laravel迁移文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$table-&gt;json(<span class="string">'rest'</span>)-&gt;nullable();</span><br><span class="line"></span><br><span class="line">$table-&gt;string(<span class="string">'rest'</span>)-&gt;nullable()-&gt;unique()-&gt;virtualAs(<span class="string">'`oauth`-&gt;&gt;"$.google_id"'</span>);</span><br></pre></td></tr></table></figure><p>有了索引后,当我们执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="string">`rest`</span>-&gt;<span class="string">'$.google_id'</span> = <span class="string">'xxx'</span> # 通常使用这种更加简单的形式</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="string">`rest`</span>-&gt;&gt;<span class="string">'$.google_id'</span> = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"># 上面两种表达式会被mysql的优化器在查询阶段自动优化为 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> google_id = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><h4 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h4><ul><li><p><code>virtualAs(oauth-&gt;&quot;$.google_id&quot;&#39;);</code> 使用 <strong>-&gt;</strong>符号来创建生成列会出现无法使用索引的情况, 原因不是很明了,需要继续研究一下手册. 另外对于创建语句 <code>GENERATED ALWAYS</code>的作用也不是很明了.</p></li><li><p>关于null, 经常会看到一种言论是mysql中使用null作为字段默认值会出现无法索引的情况.但经过查询了解,发现这是一种老中医理论. 我更倾向于使用null作为默认值, 而不是 ‘’/0/0.0 ,我认为null的表达性更好, laravel中也无时无刻不在提现这种思想.</p></li><li>关于json的使用, 最近的项目中,我大部分核心表都有一个json字段,做一些非核心数据的存储和冗余. </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql5.7.8之后开始原生支持json. 在类似mongodb这种nosql数据库中,json存储数据是非常自然的, 在mysql中合理的使用json,能够带来极大的便利&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql json" scheme="http://beian.miit.gov.cn/tags/mysql-json/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用路由模型绑定</title>
    <link href="http://beian.miit.gov.cn/posts/elegant-use-of-routing-model-bindings.html"/>
    <id>http://beian.miit.gov.cn/posts/elegant-use-of-routing-model-bindings.html</id>
    <published>2018-09-21T07:44:20.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><blockquote><p>laravel5.1/5.2发布的路由模型绑定是一个非常强大的功能,dingo/api中想要使用路由模型绑定需要引入bindings组件到dingo的路由组中</p></blockquote><a id="more"></a><h4 id="路由中的参数命名"><a href="#路由中的参数命名" class="headerlink" title="路由中的参数命名"></a>路由中的参数命名</h4><p>如有需要,使用资源的单数形式为路由命名,而不是 {id}/{slug}/{code}等等</p><p>正确的示例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api.php</span></span><br><span class="line"></span><br><span class="line">Route::resource(<span class="string">'posts'</span>, <span class="string">'PostController'</span>); <span class="comment">// laravel会将参数命名为 post</span></span><br><span class="line">Route::get(<span class="string">'users/&#123;user&#125;/posts'</span>, <span class="string">'PostController@index'</span>);</span><br><span class="line">Route::get(<span class="string">'posts/&#123;post&#125;/comments'</span>, <span class="string">'CommentController@index'</span>);</span><br></pre></td></tr></table></figure><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>以<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>的文章为例,使用RESTFul 风格可以得到以下几条路由</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api.php</span></span><br><span class="line"></span><br><span class="line">Route::get(<span class="string">'posts'</span>, <span class="string">'PostController@index'</span>); <span class="comment">// 首页/基础帖子展示</span></span><br><span class="line">Route::get(<span class="string">'users/&#123;user&#125;/posts'</span>, <span class="string">'PostController@index'</span>); <span class="comment">// 某个用户的帖子</span></span><br><span class="line">Route::get(<span class="string">'collections/&#123;collections&#125;/posts'</span>, <span class="string">'PostController@index'</span>) <span class="comment">// 某个专题下的帖子</span></span><br></pre></td></tr></table></figure><p>可以看到,这里我使用了同一个方法来处理这三条路由.</p><p>接下来定义路由模型绑定,这里使用显式绑定,以获得较大的灵活性</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RouteServiceProvider.php</span></span><br><span class="line"></span><br><span class="line">Route::model(<span class="string">'user'</span>, User::class);</span><br><span class="line">Route::model(<span class="string">'collection'</span>, Collection::class)</span><br></pre></td></tr></table></figure><p>然后看看控制器中的定义</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostController.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">($parent = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $query = $parent ? $parent-&gt;posts() : Post::query();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// e.g</span></span><br><span class="line">    $posts = $query-&gt;latest()-&gt;paginate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用第一条路由访问我们的帖子时, $parent得到的是一个null, <code>$query = Post::query</code>.</p><p>访问后两条路由时,由于路由模型绑定,$parent 被赋值为具体的model. 此时可以通过model中定义的关联关系来获取query. 通过显示绑定和关联关系的定义,使得$parent-&gt;posts()足够抽象,不依赖于具体的model.具有强大的通用性.</p><h4 id="p-s"><a href="#p-s" class="headerlink" title="p.s"></a>p.s</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User.php</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">posts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(Post::class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Collection.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">posts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;belongsToMany(Post::class, <span class="string">'collection_post'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h2><p>对于, 如 我的文章列表,我的订单等我们可能会这样定义我们的 RESTFul 路由</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里单数形式的user就代表着me的意思, 参考于github api</span></span><br><span class="line">Route::get(<span class="string">'user/posts'</span>, <span class="string">'PostController@index'</span>);</span><br><span class="line">Route::get(<span class="string">'user/orders'</span>, <span class="string">'OrderController@index'</span>);</span><br></pre></td></tr></table></figure><p>甚至,依旧已简书为例,简书有两个板块<a href="https://www.jianshu.com/trending/weekly?utm_medium=index-banner-s&amp;utm_source=desktop" target="_blank" rel="noopener">30日热门</a>和<a href="https://www.jianshu.com/trending/monthly?utm_medium=index-banner-s&amp;utm_source=desktop" target="_blank" rel="noopener">7日热门</a>, 我们可能会有这样两条路由</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'hot-30/posts'</span>, <span class="string">'PostController@index'</span>);</span><br><span class="line">Route::get(<span class="string">'hot-7/posts'</span>, <span class="string">'PostController@index'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者根据推荐算法通过用户画像推荐不同的文章</span></span><br><span class="line">Route::get(<span class="string">'recommend/posts'</span>, <span class="string">'PostController@index'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不要激动,接下来不是算法环节?</p></blockquote><p>?现在的问题是,如何依旧使用同一个方法实现?的几条路由呢?</p><p><strong>我们换一种思路.前面我们都是在控制器层面做抽象,然后把具体逻辑交给路由层.可面对上面的需求依旧有些力不从心,那我们不妨寻找一下上面需求的共同点,再提取一层抽象</strong></p><blockquote><p>当然更简单的思路是 拆开几个方法写就ok啦,搞这么麻烦是吧.见仁见智.瞎折腾就是了</p></blockquote><p>我们可以这么做</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api.php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &#123;virtual&#125; 来匹配上面的hot-30,hot-7,recommend 等等</span></span><br><span class="line">Route::get(<span class="string">'&#123;virtual&#125;/posts'</span>, <span class="string">'PostController@index'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RouteServiceProvider.php</span></span><br><span class="line"></span><br><span class="line">Route::bind(<span class="string">'virtual'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($value)</span> </span>&#123;</span><br><span class="line">    $virtual = <span class="string">"App\\Virtual\\"</span> . studly_case($value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> $virtual($value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的做法是, 路由模型绑定是基于model,或者说 entity 的<em>(在symfony中model被称作entity)</em>.但是hot-30/hot-7/recommend 并不基于model.<em>(当然也可以基于model,不过这不是我们本次讨论的重点)</em>, </p><p>那我们不妨使用一个virtual 来承载它们, virtual是一个和entity相近又相反的意思.在这里再适合不过了.来看看具体实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hot30.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Virtual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Post</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hot30</span> <span class="keyword">extends</span> <span class="title">Virtual</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">posts</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ids = ...; <span class="comment">// service</span></span><br><span class="line">        <span class="keyword">return</span> Post::whereIn(<span class="string">'id'</span>, $ids);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hot7,Recommend同理. 这样我们又承接起了上面控制器的代码.这里的posts()的作用就相当于比如User.php中的posts()的作用,但是却更加的灵活.</p><blockquote><p>鲁迅说过: 不要害怕在你的app下添加目录</p></blockquote><p>我只是分享了一个简单的想法,更多的用法等着你来探索.</p><p>successful!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;Basic&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;laravel5.1/5.2发布的路由模型绑定是一个非常强大的功能,dingo/api中想要使用路由模型绑定需要引入bindings组件到dingo的路由组中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="laravel api" scheme="http://beian.miit.gov.cn/tags/laravel-api/"/>
    
  </entry>
  
  <entry>
    <title>过程抽象解一般方程</title>
    <link href="http://beian.miit.gov.cn/posts/process-abstract-solution-general-equation.html"/>
    <id>http://beian.miit.gov.cn/posts/process-abstract-solution-general-equation.html</id>
    <published>2018-09-21T02:06:45.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="传统解方程"><a href="#传统解方程" class="headerlink" title="传统解方程"></a>传统解方程</h2><h4 id="二次函数为例"><a href="#二次函数为例" class="headerlink" title="二次函数为例"></a>二次函数为例</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Polynomialdeg_2.svg/233px-Polynomialdeg_2.svg.png" alt="img"></p><p>解析式：<strong>f(x) = x² - x -2</strong></p><p>在数学中，<strong>二次函数</strong> <code>f(x) = ax² + bx + c</code> (a ≠ 0，且a、b、c 是常数)的多项式函数，其中，x 为自变量，a, b, c 分别是函数解析式的二次项系数、一次项系数和常数项。二次函数的图像是一条主轴平行于<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d" alt="y"> 轴的抛物线</p><blockquote><p>令f(x) = 0 可以将二次函数转换成二次方程,该方程的解称为方程的根或者函数的零点(y = 0是x的值)</p><p>通过判别式 △ = b² - 4ac 来判定方程根的情况</p></blockquote><h4 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解</h4><p>例 x² - 3x + 2 = 0 可以将左边的方程使用十字相乘法分解成 (x - 1) (x - 2) = 0, 所以分别有 x - 1 = 0 或者 x - 2 = 0 从而得到方程的两个解</p><h4 id="求根公式"><a href="#求根公式" class="headerlink" title="求根公式"></a>求根公式</h4><p>对<code>ax² + bx + c = 0 (a ≠ 0)</code>它的根可以表示为：</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ddcdc99b985b5d370851854c27f1e803c29ebd6a" alt="img"></p><h2 id="区间折半法求任意函数的零点"><a href="#区间折半法求任意函数的零点" class="headerlink" title="区间折半法求任意函数的零点"></a>区间折半法求任意函数的零点</h2><p>f(x) = 0, f是一个连续的函数. 如果给定点a和b有 <code>f(a) &lt; 0 &lt; f(b)</code>, 那么f在a和b之间必然有一个零点(f(x) = 0的点).为了确定这个零点. 我们只需要缩小 a和b的区间从而确定零点所在的范围.具体的做法是</p><p>令 x是a和b的平均值并计算出 f(x). 如何f(x) &gt; 0 那么 a和x之间必然有一个f的零点. f(x) &lt; 0则反之</p><p>实现</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> a b)</span><br><span class="line">     <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 更加通用的寻找一个函数的零点</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search</span> f lower upper)</span><br><span class="line">  <span class="comment">; 判断是否可以接收误差区间</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x y)) <span class="number">0.001</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">middle</span> (<span class="name">average</span> lower upper)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> lower upper)</span><br><span class="line">        middle</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">mid-value</span> (<span class="name">f</span> middle))) <span class="comment">; 求解中间值</span></span><br><span class="line">            (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">positive?</span></span> mid-value) <span class="comment">; 判断大小进行下一次操作</span></span><br><span class="line">                   (<span class="name">search</span> f lower middle))</span><br><span class="line">                  ((<span class="name"><span class="builtin-name">&lt;</span></span> mid-value <span class="number">0</span>)</span><br><span class="line">                   (<span class="name"><span class="builtin-name">negative?</span></span> f middle upper))</span><br><span class="line">                  (<span class="name"><span class="builtin-name">else</span></span> middle))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">half-interval-method</span> f a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">a-value</span> (<span class="name">f</span> a))</span><br><span class="line">        (<span class="name">b-value</span> (<span class="name">f</span> b)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">negative?</span></span> a-value) (<span class="name"><span class="builtin-name">positive?</span></span> b-value))</span><br><span class="line">           (<span class="name">search</span> f a b))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">negative?</span></span> b-value) (<span class="name"><span class="builtin-name">positive?</span></span> a-value))</span><br><span class="line">           (<span class="name">search</span> f b a))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">            (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"Values are not of opposite sign"</span>)))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">; 折半法解 x³ - 2x - 3 = 0 在1和2之间的根</span></span><br><span class="line">(<span class="name">half-interval-method</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">-</span></span> (<span class="name"><span class="builtin-name">*</span></span> x x x) (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> x) <span class="number">3</span>))</span><br><span class="line">                      <span class="number">1</span></span><br><span class="line">                      <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>区间折半法给出了一种解方程的通用方法.其是高度抽象的且适用于计算机的可以解任何线性方程的方法.</p><h2 id="找出函数的不动点"><a href="#找出函数的不动点" class="headerlink" title="找出函数的不动点"></a>找出函数的不动点</h2><p><strong>定义:</strong>f(x) = 0,称为f(x) 的零点. 而f(x) = x. x称为f(x)的不动点, </p><p>例如 <code>f(x) = -x + 3</code>令 x = -x + 3 解得 x = - (3/2). 这就是方程f(x)的不动点.</p><p>当然并不是所有的函数都有不动点,如 <code>f(x) = x + 2</code>,我们找不到一个x使得 x = x + 2 (当然0除外)</p><p>🤔 <strong>给定任意函数,如何找到其不动点呢?</strong></p><p>对于某些函数,通过某个初始猜测触发,反复的应用f</p><p><code>x, f(x), (f(fx)), f(f(f(x))),...,</code></p><p>直到值的变化不大时,就可以找到它的一个不动点.</p><p>这种特殊的不动点称为<strong>吸引不动点</strong> , 其严格定义是: 对于函数的不动点x0, 在足够接近x0的定义域(x相对于f(x)的取值范围称为定义域)的任何x, 通过迭代序列 <code>x, f(x), f(f(x))…</code> , x会主键收敛于x0</p><p>如何才是 “足够接近”是个微妙的问题, 在计算机中不断的 cos(cos(cos(cos(……R, 它会快速的收敛大雨 0.73908513. 这就是不动点. 这种情况下 足够接近的约束实际上是不存在的</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/Cosine_fixed_point.svg" alt="https://upload.wikimedia.org/wikipedia/commons/e/ea/Cosine_fixed_point.svg"></p><p>根据上面的定义我们抽象出一个寻找函数不懂点的过程</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> a b)) tolerance))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next</span> (<span class="name">f</span> guess)))</span><br><span class="line">      <span class="comment">; 计算出的下一个猜测值和当前猜测值的差在允许误差范围内则表示已经收敛完毕, next既是我们需要寻找的不动点</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> guess next)</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">iter</span> next))))</span><br><span class="line">  (<span class="name">iter</span> guess))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 测试 cos的不动点</span></span><br><span class="line">(<span class="name">fixed-point</span> cos <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="通过寻找不动点的方式求平方根"><a href="#通过寻找不动点的方式求平方根" class="headerlink" title="通过寻找不动点的方式求平方根"></a>通过寻找不动点的方式求平方根</h4><p>x² = y.  转换一下可以得到 x = y/x. 现在只要找到一个x使得 x = y/x . 那就这个x就是y的平方根. 且通过上面的描述,我们可以知道这样的x也称为 y/x 的不动点. 我们已经有了一个寻找函数不动点的过程.现在应用看看</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-sqrt</span> y)</span><br><span class="line">  (<span class="name">fixed-point</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">/</span></span> y x)) <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">my-sqrt</span> <span class="number">4</span>) <span class="comment">; 这不ok,我们陷入了一个iter无法自拔了...</span></span><br></pre></td></tr></table></figure><p>初始化时 x = x1; x2 = y/x1; x3 =  y/(y/x1) = x1  这里陷入了一个死循环,我们始终在x3 ~ x1之间震荡.</p><p>由于实际答案总是在 x 和 y/x 之间</p><blockquote><p>x <em> y/x = y  平方根总是在中点部分. 其余被乘数和乘数则一定会有一个大于中间值.比如 16的平方根是4, 那16的其余乘数比如 1 \</em> 16 / 2 * 8 / 0.5 * 32等等 总是有一个乘数会大于4.</p></blockquote><p>既然有了上一次的结论,那我们可以不适用 y/x作为下一次的猜测值, 而使用x和 y / x的平均值作为下一次的猜测值,从而使每一次的猜测值变化都没有那么剧烈</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">my-sqrt</span> y)</span><br><span class="line">  (<span class="name">fixed-point</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name">average</span> x (<span class="name"><span class="builtin-name">/</span></span> y x))) <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><p>successful!</p><p>将过程作为参数传递,能够显著增强我们的程序设计语言的表达能力.可以表述计算的一般性过程,与其中所涉及的特定函数无关.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;传统解方程&quot;&gt;&lt;a href=&quot;#传统解方程&quot; class=&quot;headerlink&quot; title=&quot;传统解方程&quot;&gt;&lt;/a&gt;传统解方程&lt;/h2&gt;&lt;h4 id=&quot;二次函数为例&quot;&gt;&lt;a href=&quot;#二次函数为例&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kmp 算法简介及 next 数组推导</title>
    <link href="http://beian.miit.gov.cn/posts/introduction-of-kmp-algorithm-and-derivation-of-next-array.html"/>
    <id>http://beian.miit.gov.cn/posts/introduction-of-kmp-algorithm-and-derivation-of-next-array.html</id>
    <published>2018-05-01T07:18:51.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在<strong>不匹配时本身就包含足够的信息</strong>来确定<strong>下一个匹配</strong>将在哪里开始的发现，从而避免重新检查先前匹配的字符。</p><a id="more"></a><p>比如下面这种情况<br><img src="http://asset.eienao.com/15250626677035.jpg" alt></p><p><img src="http://asset.eienao.com/15250673175700.gif" alt></p><p>gif中可以看出，匹配失败之后kmp算法不对主字符串的指针进行任何的回退，其关心的是对搜索词指针的处理。</p><p>细心的你可能已经感受到了一点，上面的处理是抽象的（通用的），既完全不需要知道主字符串具体是多少的情况下进行的模拟演习。</p><p>gif中模拟了指针k在字符c处失配的情况，通过这样一个预处理，在实际匹配中，如果遇到了这种情况，我们只需要从容的将搜索词指针移动到E处，然后继续匹配即可。</p><blockquote><p>补充一下，为什么搜索词在移动到 K = E的位置停了下来？<br>这里可以感性的理解，由于在移动过程中 AB成功进行了匹配，而在不知道 ‘?’所代表的具体字符是多少的情况下继续向前移动搜索词，则可能会出现错失匹配的情况。</p></blockquote><p>现在依旧已<strong>ABEABC</strong>作为搜索词，再看几种演习情况</p><p><img src="http://asset.eienao.com/15250699691851.jpg" alt></p><p><img src="http://asset.eienao.com/15250697769552.jpg" alt><br><img src="http://asset.eienao.com/15250698346450.jpg" alt><br><img src="http://asset.eienao.com/15250698836098.jpg" alt></p><p>我们来总结一下规律。<br>对于前两种情况K指针都没有移动到起点0，而是中途位置停了下来。<br>可以发现 ABEAB?与ABEABC在失配字符之前的字符<strong>ABEAB</strong> 的头部与尾部存在相同的字符<strong>AB</strong>。</p><p>ABEA?和ABEAB在失配之前的字符<strong>ABEA</strong>中，头部和尾部存在相同的字符 <strong>A</strong>。</p><p><img src="http://asset.eienao.com/15250705065666.jpg" alt><br>对于这种字符我们称之为前后缀，通过上面的图我们发现<strong>K指针在失配时移动到的位置刚好是前缀的后一个字符</strong>。但一个字符串的前缀并不是唯一的，所以这句话非常不严谨。</p><blockquote><p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br><img src="http://asset.eienao.com/15250708572240.jpg" alt><br>出自 阮一峰 <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p></blockquote><p>了解了前缀与后缀之后，我们再次定义。<br>当指针j所指向的字符与指针k所指向的字符失配时，失配之前的字符存在一个前缀集合和一个后缀集合，我们可以得到 </p><p><code>k&#39; = max(0 ~ k-1的前缀集合 ∩ 0 ~ k-1的后缀集合后缀集合)</code></p><p>k’的含义从公式中看的很清楚（前缀与后缀的交集的最大值）。而另一层含义则是，如果搜索词下标从0开始计算，当k处失配时，我们只需要将k移动到k’处继续匹配即可。</p><p>kmp算法的通常把计算出的k’放到next数组中存储<br><strong>next[k] = k’</strong>。当我们实战中在指针k处失配时,我们只需要将k指针回退到k’处，既k = k’ = next[k]即可。</p><p>确实如我们之前所言，通过定义可以清楚的认识到，计算next数组完全不需要主字符串参与，完全是搜索词自匹配计算<code>k&#39; = max(0~k-1的前缀集合 ∩ 0~k-1的后缀集合)</code>的过程。</p><p>这个定义虽然很严谨，便于理解，但却不能很好的使用计算机语言描述出来。下面看看便于计算机理解的next数组的推导过程。这应该是整个kmp算法最难理解的地方</p><h2 id="next数组推导"><a href="#next数组推导" class="headerlink" title="next数组推导"></a>next数组推导</h2><p>根据next数组的定义,我们可以有</p><p>若 <code>next[j] = k</code>，则 <code>w[0 ~ k-1] = w[j-k ~ j-1]</code></p><p>要明白这两者之间是充分必要条件关系，既<br>若 <code>w[0 ~ k-1] = w[j-k ~ j-1]</code>则<code>next[j] = k</code></p><p>下图图中的情况为一种满足定义的情况<code>next[6] = 2</code><br><img src="http://asset.eienao.com/15251567062585.jpg" alt></p><blockquote><p>这个我不知道怎么证明，因为这是由next数组的定义得到的，所以也不需要证明。</p></blockquote><p>现在已经知道了<code>next[j] = k</code>，顺理成章，接下来我们继续求<code>next[j+1]</code>，<code>next[j+1]</code>求解过程中存在两种情况</p><h3 id="w-k-w-j"><a href="#w-k-w-j" class="headerlink" title="w[k] == w[j]"></a>w[k] == w[j]</h3><p>根据上面的推导，当 <code>w[k] == w[j]</code>时，有<code>w[0 ~ k] = w[j-k ~ j]</code>， 则可以得到 <code>next[j+1] = k + 1</code><br><img src="http://asset.eienao.com/15251568780076.jpg" alt></p><h3 id="w-k-w-j-1"><a href="#w-k-w-j-1" class="headerlink" title="w[k] != w[j]"></a>w[k] != w[j]</h3><p>若<code>w[k] != w[j]</code>则进入了熟悉的字符串失配环节，明确一下，谁与谁的比较中产生了失配？下图是一个符合我们讨论的例子</p><p><img src="http://asset.eienao.com/15251569142399.jpg" alt></p><p>可以看出在寻找字符串<strong>ABEFABA</strong>的最大前后缀交集时，<strong>k</strong>与<strong>j</strong>发生了失配</p><p><img src="http://asset.eienao.com/15251570164284.jpg" alt></p><p>在kmp算法中如果发生了这种情况，则另 <code>k = next[k]</code>，然后再次让w[k]与w[j]比较。那么问题来了</p><ol><li><p>为什么当<code>w[k] != w[j]</code>时,令 <code>k = next[k]</code>, 而不是k = k-1或者其他呢?</p><p> w[k]与w[j]失配时， k至少要移动到next[k]处才能使得<strong>k</strong>与主字符串的<strong>j</strong>继续匹配。这是next数组的定义，现在只不过在使用这个定义而已</p></li><li><p><code>w[k] != w[j]</code>，所以另<code>k&#39; = next[k]</code>，假如此时<code>w[k&#39;] == w[j]</code>，如何证明 <code>w[0 ~ k&#39;] == w[j-k&#39; ~ j]</code> 呢?(图中粉色部分)</p><p> <img src="http://asset.eienao.com/15251572646346.jpg" alt><br> 由<code>k&#39; = next[k]</code>得到<code>w[0 ~ k&#39;-1] == w[k-k&#39; ~ k-1]</code></p><p> 由<code>next[j] = k</code>得到<code>w[0 ~ k-1] == w[j-k ~ j-1]</code></p><p> 因为 <code>w[0 ~ k-1] == w[j-k ~ j-1]</code><br> 所以 <code>w[k-k&#39; ~ k-1] == w[j-k&#39; ~ j-1]</code></p><blockquote><p>这里属于感性证明，能力不足暂时无法使用公式证明</p></blockquote><p> 所以 <code>w[0 ~ k&#39;-1] == w[j-k&#39; ~ j-1]</code> </p><p> 又因为 <code>w[k&#39;] == w[j]</code><br> 所以 <code>w[0 ~ k&#39;] == w[j-k&#39; ~ j]</code></p><p> 由 <code>w[0 ~ k&#39;] == w[j-k&#39; ~ j]</code>，得到 next[j+1] = k’ + 1</p><p> 这是假如此时 <code>w[k&#39;] == w[j]</code>的情况，但大多数情况是<code>w[k&#39;] != w[j]</code>的，这种情况我们在算法实现中讨论。</p></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>next数组实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getNext</span><span class="params">($word)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $next = [<span class="number">-1</span>];</span><br><span class="line">    $len = strlen($word);</span><br><span class="line">    $k = <span class="number">-1</span>;</span><br><span class="line">    $j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($j &lt; $len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($k == <span class="number">-1</span> || $word[$j] == $word[$k]) &#123;</span><br><span class="line">            $next[++$j] = ++$k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $k = $next[$k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>next[0] = -1</code> 中-1是一种特殊标志，方便进行判断。在上面的<code>w[k] != w[j]</code>时，我们另 <code>k = next[k]</code>然后再去判断w[k]是否等于w[j]，如果还是不相等，则再另<code>k = next[k]</code>像这样一直循环下去。<br>但是循环总归有个尽头，在尽头会出现这种情况，此时k = 0，<code>w[k] != w[j]</code>，按照算法<code>k = next[0] = -1</code>。</p><p>因此当我们看到 k = -1时，我们就能够知道 w[0 ~ k]不存在前缀与后缀的交集，既 <code>max(0~k的前缀集合 ∩ 0~k的后缀集合) = 0</code> 所以我们另 <code>next[k+1] = 0</code>即可</p><p>上面的算法为了保持简洁性，令特殊值为-1，使得一个if，else可以覆盖三种情况，当然你用下面的写法也是一个意思</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($k == <span class="number">-1</span>) &#123;</span><br><span class="line">    $next[++$j] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($word[$j] == $word[$k]) &#123;</span><br><span class="line">    $next[++$j] = ++$k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $k = $next[$k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细实现含测试用例</strong><br><a href="https://github.com/weiwenhao/algorithm/blob/master/src/KMP.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/src/KMP.php</a></p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>kmp算法实际上在字符串匹配中使用的情况并不多，虽然其时间复杂度是O(m+n)，但实际上其表现跟朴素算法并不会差太多，在学习的过程中其实也应该发现了，能够部分匹配的情况其实不多见。<br>不得不说kmp算法非常的难以理解，细节太多很容易陷入一个拆东墙补西墙的情况，各种牛角尖钻到停不下来。但是其状态机的思想，以及next数组的推导过程却非常值得学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在&lt;strong&gt;不匹配时本身就包含足够的信息&lt;/strong&gt;来确定&lt;strong&gt;下一个匹配&lt;/strong&gt;将在哪里开始的发现，从而避免重新检查先前匹配的字符。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Amazing tree —— 二叉查找树</title>
    <link href="http://beian.miit.gov.cn/posts/amazing-tree-two-fork-lookup-tree.html"/>
    <id>http://beian.miit.gov.cn/posts/amazing-tree-two-fork-lookup-tree.html</id>
    <published>2018-04-20T08:12:02.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二分查找很好的解决了查找问题，将时间复杂度从 O(n)降到了O(logn)。<br>但是二分查找的前提条件是数据必须是有序的，并且具有线性的下标。<br>对于线性表，可以很好的应用二分查找，但是在插入和删除操作时则可能会造成整个线性表的动荡，时间复杂度达到了O(n)<br>链表更是没法应用二分查找。</p></blockquote><p>于是有了下面将要介绍的算法，其在查找、插入、删除都能够达到O(logn)的时间复杂度 —— <strong>二叉查找树</strong></p><a id="more"></a><p>见名知意，其数据结构基础为二叉树，初次接触到二叉树时并没有感觉到其有什么突出之处。但看到通过二叉树构建出的二叉查找树方案时，确被深深的震撼了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><p>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>任意结点的左、右子树也分别为二叉查找树；<br>没有键值相等的结点。</p><p>根据上面的规则我们先来定义一颗二叉树<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a99f8188?w=478&amp;h=468&amp;f=jpeg&amp;s=29956" alt></p><p>这里可以很容易看出其规律，不需要过多的解释。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>现在再插入一个元素13。 13&gt;12所以往右边走来到14，13 &lt; 14则左走，发现14没有左孩子，所以将13插入之，得到下面这张图<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9a9885d?w=534&amp;h=483&amp;f=jpeg&amp;s=35531" alt></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>按照上面插入的思路，可以很容易实现搜索操作。并且发现其查找的时间复杂度就为这颗树的深度。</p><blockquote><p>根据完全二叉树的性质，具有n个结点的完全二叉树的深度为 <code>[logn] + 1</code></p></blockquote><p>忽略掉<code>+1</code>得到二叉查找树的查找时间复杂度为 <code>O(logn)</code>，但是实际上并非如此，后面我们分析。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉树的遍历有前序、中序、后序遍历三种方式，这里着重介绍后序遍历。<br>对二差查找树进行中序遍历时，可以得到一个<code>asc</code>的排序结果。如上面的树中序遍历的结果是 <strong>3, 8, 9, 12, 13, 14</strong>。<br><code>中序遍历从一颗子树最左的节点开始输出，既该树的最小值</code>。实现中序遍历只需要将<strong>数据收集点</strong>置于左递归点与右递归点之间，这样说还是有些含糊了，看代码吧</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">inorder</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;left) &#123;</span><br><span class="line">        $data = array_merge($data, <span class="keyword">$this</span>-&gt;inorder($root-&gt;left)); <span class="comment">//左孩子递归点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $data[] = $root-&gt;data; <span class="comment">// 这里是中序遍历的数据收集点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;right) &#123;</span><br><span class="line">        $data = array_merge($data, <span class="keyword">$this</span>-&gt;inorder($root-&gt;right)); <span class="comment">// 右孩子递归点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前驱与后继， 以9节点为例， 12属于9的后继，8属于9的前驱。</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>我们给这颗树多加几个结点<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0add13dd2?w=968&amp;h=703&amp;f=jpeg&amp;s=76963" alt></p><p>删除树中的结点分为很多种情况，如被删除的结点不存在子结点，只存在左子树/右子树，左右子树都存在，这里已覆盖率最广的左右子树都存在为例。</p><blockquote><p>分析一个需求时要并不是需求存在多少中情况我们就写多少种情况。而应该分析情况之间的关系，是否存在重复，或者属于关系等，程序员应该做的就是提取需求的本质，力求于最简洁的实现</p></blockquote><p>现在我们打算删除25这个结点，你会怎么做？<br>如果只是简单把18来顶替原来25的位置，则需要对18这颗子树的孩子们进行重新调整。18只有三个孩子还好，但是当孩子成千上万时，显然会造成大面积的调整。<br>所以我希望能够找到一个更好的节点来代替25，按照算法导论中的描述，我们应该寻找该结点的前驱或者后继来代替，比如图中的24和27分别是25的前驱和后继。</p><blockquote><p>为什么要使用前驱或者后缀来代替？这点我十分不确定，我给自己的理由是</p><ol><li>该结点是一个特殊值，属于某颗子树的最大值或者最小值，具有确定性，可以被比较好的定义且查找出来。</li><li>由于该结点属于被删除节点的前驱或者后继，则删除该结点对数据结构造成的影响最小。<em>我并不确定是对什么的数据结构造成的影响最小</em></li></ol></blockquote><p>上面描述的情况的图解如下 ↓<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9bdc5fc?w=756&amp;h=537&amp;f=jpeg&amp;s=50523" alt><br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9b88949?w=696&amp;h=457&amp;f=jpeg&amp;s=47267" alt></p><p>删除还存在一些其他的情况,比如下面这种情况↓<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0ae694229?w=909&amp;h=529&amp;f=jpeg&amp;s=52024" alt></p><p>对于这种情况直接将30提升到25即可，接下来看一下看php的代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span><span class="params">($root, $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!$root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;data === $data) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;left) &#123;</span><br><span class="line">            <span class="comment">// 左转</span></span><br><span class="line">            $node = $root-&gt;left;</span><br><span class="line"></span><br><span class="line">            $parent = $root;</span><br><span class="line">            $toward = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ($node-&gt;right) &#123;</span><br><span class="line"></span><br><span class="line">                $parent = $node;</span><br><span class="line">                $toward = <span class="string">'right'</span>;</span><br><span class="line"></span><br><span class="line">                $node = $node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $root-&gt;data = $node-&gt;data;</span><br><span class="line"></span><br><span class="line">            $parent-&gt;&#123;$toward&#125; = <span class="keyword">$this</span>-&gt;delete($node, $node-&gt;data);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> $root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($root-&gt;data &gt; $data) &#123;</span><br><span class="line">        <span class="comment">// 如果root的左孩子没有被删除,那就原样返回回来, 如果被删除了,那就找个孩子代替</span></span><br><span class="line">        $root-&gt;left = <span class="keyword">$this</span>-&gt;delete($root-&gt;left, $data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $root-&gt;right = <span class="keyword">$this</span>-&gt;delete($root-&gt;right, $data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于php有内存回收机制，因此我们没有办法像c一样直接去修改内存，所以这里借助递归的特性来解决这个问题 <code>$root-&gt;left = $this-&gt;delete($root-&gt;left, $data);</code> 做类似这样一个处理，这可能会有些理解上的困难。但总归还是能够明白的~</p><p>除了递归解决外，也可以用下面这种办法。<br>即定义一个parent和toward来做一个导向，这在上面的代码中也有体现。<strong>该方法更加适用于迭代处理</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$parent = $root;</span><br><span class="line">$toward = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($node-&gt;right) &#123;</span><br><span class="line"></span><br><span class="line">    $parent = $node;</span><br><span class="line">    $toward = <span class="string">'right'</span>;</span><br><span class="line"></span><br><span class="line">    $node = $node-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的实习细节和调用示例请参考单元测试。</p><p><a href="https://github.com/weiwenhao/algorithm/blob/master/test/BinarySearchTreeTest.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/test/BinarySearchTreeTest.php</a></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><a href="https://github.com/weiwenhao/algorithm/blob/master/src/BinarySearchTree.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/src/BinarySearchTree.php</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于php没有像js一样的字面量对象或者c一样的struct。因此直接使用对象来表示树中的结点</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $data;</span><br><span class="line">    <span class="keyword">public</span> $left;</span><br><span class="line">    <span class="keyword">public</span> $right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($data, $left = null, $right = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = $data;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = $left;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = $right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查找的时候指出了，二叉查找树的查询的时间复杂度并不是严格意义上的O(logn) 是因为有这样的情况发生， 假设需要插入 <strong>12, 10, 9, 5, 4, 1</strong>这几个数据，那么我们会得到这样一颗歪脖子树</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0e77d4df1?w=628&amp;h=729&amp;f=jpeg&amp;s=29661" alt><br>此时的时间复杂度俨然已经变成了O(n)，不过对于这样的问题自然已经有解决方案。下一节将会在<strong>AVL树</strong>和<strong>红黑树</strong>这两种解决方案中选一种来BB~</p><p>当然二叉查找树依旧是各种树的根基，还请认真理解。<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0e7d2e92c?w=788&amp;h=162&amp;f=jpeg&amp;s=22352" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二分查找很好的解决了查找问题，将时间复杂度从 O(n)降到了O(logn)。&lt;br&gt;但是二分查找的前提条件是数据必须是有序的，并且具有线性的下标。&lt;br&gt;对于线性表，可以很好的应用二分查找，但是在插入和删除操作时则可能会造成整个线性表的动荡，时间复杂度达到了O(n)&lt;br&gt;链表更是没法应用二分查找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是有了下面将要介绍的算法，其在查找、插入、删除都能够达到O(logn)的时间复杂度 —— &lt;strong&gt;二叉查找树&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://beian.miit.gov.cn/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://beian.miit.gov.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法及正确性分析</title>
    <link href="http://beian.miit.gov.cn/posts/dijkstra-algorithm-and-correctness-analysis.html"/>
    <id>http://beian.miit.gov.cn/posts/dijkstra-algorithm-and-correctness-analysis.html</id>
    <published>2018-04-11T09:39:08.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近朋友问了一个关于列车调度的问题，求两个地点之间的最短路径。听起来挺简单的问题，可是仔细思考后发现完全无从下手。最近空闲下来便恶补了一番数据结构。</p><p>求最短路径的方法有Dijkstra，Floyd，BFS等等 其中Floyd适合多源最短路径，BFS适合无权值的情况，这里问题属于单源最短路径，所以我们采用Dijkstra算法.</p><a id="more"></a><p>开干吧！拿出地铁卡就是一顿画，现在我们就把问题抽象为求<strong>宝安中心-老街</strong>的最短路径</p><p><img src="http://asset.eienao.com/15233494076868.jpg" alt></p><p>开始之前首先我们介绍几个概念</p><h3 id="found集合"><a href="#found集合" class="headerlink" title="found集合"></a>found集合</h3><p>对于这种起点到某个顶点的真正的最短路径，我们称它为全局最短路径。已经找到全局最短路径的顶点，我们将其储在found集合中.现在来初始化一下found</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始时,我们已知的就只有宝安中心到宝安中心的最短路径</span></span><br><span class="line">$found = [<span class="string">'宝安中心'</span>];</span><br></pre></td></tr></table></figure><h3 id="dist集合"><a href="#dist集合" class="headerlink" title="dist集合"></a>dist集合</h3><p>用来存储起点(宝安中心)到某个顶点u， 相对于S的最短路径。通俗解释就是：宝安中心到世界之窗经过了新安，那么必须有新安∈ S。 否则我们无法直接知道其相对最短路径，在dist中则将其记为不可能存在的大值，用来表示这个点我们目前还没有办法探索到。</p><blockquote><p>dist中存储的最短路径称之为相对于S的最短路径。下文我们简称为相对最短路径，和其对应的我们有一个全局最短路径</p></blockquote><p>  初始一下dist集合</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX = <span class="number">65525</span>; <span class="comment">//65525是我们定义的一个不可能出现的大值</span></span><br><span class="line"></span><br><span class="line"> $dist = [</span><br><span class="line">     <span class="string">'深圳北站'</span> =&gt; <span class="number">5</span>,</span><br><span class="line">     <span class="string">'新安'</span> =&gt; <span class="number">8</span>,</span><br><span class="line">     <span class="string">'世界之窗'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'福田'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'老街'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'布吉'</span> =&gt; MAX,</span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>开始我们的算法~ 我们首先找到<code>dist</code>中的最小值，这里是 <code>深圳北站 =&gt; 5</code>。</p><p>顺便告诉你一个激动人心的消息，我们找到了宝安中心到深圳北站的全局最短路径。</p><blockquote><p>what?为什么dist中的最小值就是我们要找的全局最短路径(这里是<code>宝安中心-深圳北站</code>)？<br> 我们要找的不是<code>宝安中心-老街</code>的全局最短路径吗，知道了<code>宝安中心-深圳北站</code>的最短路径有什么用吗？<br> 我现在没法给你一个很好的解释，我们继续往下看。</p></blockquote><p> 继续进行算法，下面是红色顶点表示已经确定了全局最短路径的顶点</p><p> <img src="http://asset.eienao.com/15233522196267.jpg" alt><br>既然已经又找到了一个全局最短路径顶点，我们就把它更新到<strong>found</strong>集合中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$found = [<span class="string">'宝安中心'</span>, <span class="string">'深圳北站'</span>];</span><br></pre></td></tr></table></figure><p>集合found中的元素增加了一枚后，我们的视野变的宽广了。我们可以通过<code>深圳北站</code>作为一个中转更新 <strong>dist</strong>这个<strong>相对最短路径</strong>集合了</p><p><img src="http://asset.eienao.com/15233530403158.jpg" alt></p><p>通过深圳北站这个中转站我们可以得到已下相对最短路径</p><p><code>宝安中心-深圳北站-新安</code> = 5 + 2 = 7<br><code>宝安中心-深圳北站-福田</code> = 5 + 5 = 10<br><code>宝安中心-深圳北站-布吉</code> = 5 + 10 = 15</p><p>现在可以马上去替换我们<strong>dist</strong>集合中的值了吗？别急，我们需要的是相对最短路径，可不是什么阿猫阿狗就能进来的。所以我们需要进行一个比较.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果新的相对最短路径比原有的相对最短路径要小，我们则进行一个更新</span></span><br><span class="line"><span class="keyword">if</span> ($newWeight &lt; $dist[<span class="string">'新安'</span>]) &#123;</span><br><span class="line">    $dist[<span class="string">'新安'</span>] = $newWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dist</strong>集合更新如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$dist = [</span><br><span class="line">     <span class="string">'深圳北站'</span> =&gt; <span class="number">5</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'新安'</span> =&gt; <span class="number">7</span>, <span class="comment">//8 -&gt; 7</span></span><br><span class="line">     <span class="string">'世界之窗'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'福田'</span> =&gt; <span class="number">10</span>, <span class="comment">// MAX -&gt; 10</span></span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'老街'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'布吉'</span> =&gt; <span class="number">15</span> <span class="comment">// MAX -&gt; 15</span></span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><p>现在我们重复之前的步骤，找一个最小值，其就是我们下一个全局最短路径。要记住，深圳北站就不要加入查找队列了，其已经被found了</p><p>人眼扫描后可以确定下一个全局最短路径的顶点为新安。并且有了新安的中转，我们可以再次拓宽我们的视野</p><blockquote><p>为了表示清晰,对于还没有探索到相对最短路径，先隐藏其权重值</p></blockquote><p><img src="http://asset.eienao.com/15233539494101.jpg" alt><br>更新后的<strong>found</strong>和<strong>dist</strong>如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$found = [<span class="string">'宝安中心'</span>, <span class="string">'深圳北站'</span>,<span class="string">'新安'</span>];</span><br><span class="line"></span><br><span class="line">$dist = [</span><br><span class="line">     <span class="string">'深圳北站'</span> =&gt; <span class="number">5</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'新安'</span> =&gt; <span class="number">7</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'世界之窗'</span> =&gt; <span class="number">16</span>, <span class="comment">// MAX -&gt; 16 = 9+7 = 宝安-&gt;新安 + 新安-&gt;世界之窗</span></span><br><span class="line">     <span class="string">'福田'</span> =&gt; <span class="number">10</span>, <span class="comment">// MAX -&gt; 10</span></span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'老街'</span> =&gt; MAX,</span><br><span class="line">     <span class="string">'布吉'</span> =&gt; <span class="number">15</span></span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><p>再次循环 (目标已经出现在我们的视野中啦，别着急，我们还没有确定其全局最短路径) ↓</p><p><img src="http://asset.eienao.com/15233548442864.jpg" alt></p><p>更新后的s和dist如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$found = [<span class="string">'宝安中心'</span>, <span class="string">'深圳北站'</span>, <span class="string">'新安'</span>, <span class="string">'福田'</span>];</span><br><span class="line"></span><br><span class="line">$dist = [</span><br><span class="line">     <span class="string">'深圳北站'</span> =&gt; <span class="number">5</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'新安'</span> =&gt; <span class="number">7</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'世界之窗'</span> =&gt; <span class="number">16</span>,</span><br><span class="line">     <span class="string">'福田'</span> =&gt; <span class="number">10</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; <span class="number">12</span>, <span class="comment">// MAX -&gt; 12</span></span><br><span class="line">     <span class="string">'老街'</span> =&gt; <span class="number">15</span>, <span class="comment">// MAX -&gt; 15</span></span><br><span class="line">     <span class="string">'布吉'</span> =&gt; <span class="number">15</span></span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><p>再次循环↓</p><p><img src="http://asset.eienao.com/15233550139862.jpg" alt></p><p>更新后的found和dist如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$s = [<span class="string">'宝安中心'</span>, <span class="string">'深圳北站'</span>, <span class="string">'新安'</span>, <span class="string">'福田'</span>, <span class="string">'购物公园'</span>];</span><br><span class="line"></span><br><span class="line">$dist = [</span><br><span class="line">     <span class="string">'深圳北站'</span> =&gt; <span class="number">5</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'新安'</span> =&gt; <span class="number">7</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'世界之窗'</span> =&gt; <span class="number">16</span>,</span><br><span class="line">     <span class="string">'福田'</span> =&gt; <span class="number">10</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; <span class="number">12</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'老街'</span> =&gt; <span class="number">15</span>,</span><br><span class="line">     <span class="string">'布吉'</span> =&gt; <span class="number">15</span></span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><p>再次寻找dist中最小值时， 找到了我们的目标，老街。</p><p><img src="http://asset.eienao.com/15234317131194.jpg" alt></p><p><strong>算法描述完毕!</strong></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><a href="https://github.com/weiwenhao/algorithm/blob/master/src/Dijkstra.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/src/Dijkstra.php</a></p><h2 id="正确性分析"><a href="#正确性分析" class="headerlink" title="正确性分析"></a>正确性分析</h2><p>为什么dist集合中的最小值就是我们要找的全局最短路径？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$dist = [</span><br><span class="line">     <span class="string">'福田'</span> =&gt; <span class="number">10</span>, <span class="comment">// ok</span></span><br><span class="line">     <span class="string">'购物公园'</span> =&gt; <span class="number">12</span>,</span><br><span class="line">     <span class="string">'老街'</span> =&gt; <span class="number">15</span>,</span><br><span class="line"> ];</span><br></pre></td></tr></table></figure><p>以某一次dist集合的部分数据为例子，按照算法描述 <code>宝安中心-福田-购物公园</code>是我们要找的全局最短路径。现在我们假设到<code>宝安中心-购物公园</code>存在更短的路径，则存在如下两种情况</p><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p><img src="http://asset.eienao.com/15234386518638.jpg" alt></p><blockquote><p>红色区域代表集合found，表示已经找到了全局最短路径的顶点集合。<br>上面提到过，dist集合中存储的是相对于S的最短路径。</p></blockquote><p>对于这种情况，算法在进行dist集合更新操作的时候就已经判断了<code>宝安中心-福田-购物公园</code>和<code>宝安中心-X-购物公园</code>之间的更小值，因此这种情况不可能存在。我们继续来看另外一种更加可能出现的情况</p><ul><li>情况2</li></ul><p><img src="http://asset.eienao.com/15234352675359.jpg" alt></p><p>是否会存在这样一条最短路径呢？因为<code>y-购物公园</code>的距离我们并没有探索过，所以这种情况是需要慎重思考一种情况。</p><p>先让时光倒流<br><img src="http://asset.eienao.com/15234387863781.jpg" alt></p><p>此时我们的dist集合中一共有5个顶点。其中宝安中心，福田，X已经被加入到了found集合中。Y通过X的中转后被发现，购物公园通过福田中专后被发现。<br>此时根据我们的算法，将会在Y和购物公园中选取一个最小值，作为下一个全局最短路径顶点。这里算法选择了购物公园。说明<code>宝安中心-福田-购物公园 &lt; 宝安中心-X-Y</code></p><p>回到情况2<br><img src="http://asset.eienao.com/15234352675359.jpg" alt></p><p>在有了 <code>宝安中心-福田-购物公园 &lt; 宝安中心-X-Y</code>前提下。<br><code>宝安中心-X-Y-购物公园 &lt; 宝安中心-福田-购物公园</code>是否能够成立呢？假如等式不成立，则说明不可能存在一条比<code>宝安中心-福田-购物公园</code>更短的全局最短路径。</p><p>等式是否成立我相信你一目了然。</p><p><strong>正确性分析完毕！</strong></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>你可能还在惊讶于dijkstra算法为什么这么神奇？就算我们已经知道了算法步骤，分析了算法的正确性。可还是不禁会感叹，到底是怎么做到的，到底是怎么找到最优解的？</p><p>回过头去看看算法描述你会发现，其实<strong>dijkstra</strong>并不知道自己什么时候能够找到自己想要的目标，它只是关注于眼前的最优解，然后碰巧在某一时刻眼前的最优解就是要寻找的目标值。这看起来有点笨，但是在某些情况十分有用，比如路由寻址中查找最短路径必须要用到这种策略。</p><p>哦~对了，这种只关注于眼前最优解的方法其实有个更加有逼格的名字 ——  贪心算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近朋友问了一个关于列车调度的问题，求两个地点之间的最短路径。听起来挺简单的问题，可是仔细思考后发现完全无从下手。最近空闲下来便恶补了一番数据结构。&lt;/p&gt;
&lt;p&gt;求最短路径的方法有Dijkstra，Floyd，BFS等等 其中Floyd适合多源最短路径，BFS适合无权值的情况，这里问题属于单源最短路径，所以我们采用Dijkstra算法.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你真的了解 Git 吗？</title>
    <link href="http://beian.miit.gov.cn/posts/do-you-really-know-git.html"/>
    <id>http://beian.miit.gov.cn/posts/do-you-really-know-git.html</id>
    <published>2018-04-08T08:31:19.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了几遍廖雪峰的git教程和阮一峰的git教程之后，觉得自己使用git已经是得心应手了，脑中也构建出了一副关于git操作的图像。</p><blockquote><p>学习一个新东西的时候我总是喜欢把知识形象化出一个图谱在脑中，这样记忆的更加深刻。</p></blockquote><p>但是随着使用的深入，我发现我脑中的图像与git的实际行为存在出入。</p><a id="more"></a><p>稍微进入一下正题。假如你的仓库关联了远程仓库，当我们执行<code>&gt;git status</code>时，可能会有如下提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 您的分支与origin/master 一致</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>当我的队友commit and push 之后我再次执行 <code>&gt;git status</code>，我以为会有如下提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 你的分支落后于 origin/master一次提交.并且可以快速合并.执行git pull可以进行快速合并</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind &apos;origin/master&apos; by 1 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这是阮一峰大神一篇博客中看到的git操作示意图</p><blockquote><p>网上流传的大部分资料都类似这样</p></blockquote><p><img src="http://asset.eienao.com/15231690297894.jpg" alt></p><p>通过这幅图，我理所当然的认为在队友push之后，我执行git status命令会提示<code>Your branch is behind</code><br>我相信很多人都是这么认为的。</p><p>但实际产生的行为是前者，为什么会出现这样的情况？ 这就是我的问题。<br>再抽象一下这个问题，就是 <strong>git status 是对哪两个仓库进行的比较?</strong></p><p>我们分析一下提示语句 <code>Your branch is behind &#39;origin/master&#39;</code> 。不难看出是 <code>master</code>分支和 <code>origin/master</code>进行的比较</p><p>按照上面的示意图，也就是 Remote(origin/master)和Repository进行了一个比较。但是这与实际情不符。</p><p>如果你有心尝试，你会发现<code>git status</code>是一个断网之后也可以执行的命令。所以不可能是Remote和Repository进行的比较。</p><p>于是经过简单的测试，我脑海中又重新构建出一份git示意图。</p><h3 id="没有远程仓库时，我们常执行的命令有两条"><a href="#没有远程仓库时，我们常执行的命令有两条" class="headerlink" title="没有远程仓库时，我们常执行的命令有两条"></a>没有远程仓库时，我们常执行的命令有两条</h3><p><code>git add</code>和<code>git commit</code> 通过这两条命令绘制出如下图像<br><img src="http://asset.eienao.com/15231725127941.jpg" alt></p><h3 id="当关联远程仓库后，得到如下示意图"><a href="#当关联远程仓库后，得到如下示意图" class="headerlink" title="当关联远程仓库后，得到如下示意图"></a>当关联远程仓库后，得到如下示意图</h3><p><img src="http://asset.eienao.com/15231740463034.jpg" alt></p><p>这张图是我根据git命令的一些行为得到，非权威。和上面阮一峰的示意图相比，本地增加了一个 origin/master。</p><p>再稍微介绍几个命令</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>该命令没有在图上体现，其是一条复合命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull = git fetch + git merge origin/master</span><br></pre></td></tr></table></figure><p>git fetch操作将remote同步到本地的origin/master</p><p>git merge origin/master 将 origin的master分支 合并到 仓库的master分支。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>这条命令我没法确切的理解。我的猜测是， git push操作是将local的master push到了local的origin/master<br>git检测到origin变化之后，进行了一个origin到remote的同步操作</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>该命令中对比的两个仓库如图示。通过上图就能够解释，为什么 队友提交到remote之后,我执行git status没有落后提示。至此我上文提到的问题得到了解决。</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>我认为local和remote之间的行为，用推送和拉取来描述并不那么优雅。这两个词很容易会误解成，remote是一个控制中心。</p><p>实际上local和remote之间进行的只是简单的同步操作，无论是示意图还是我在介绍git fetch和git push都刻意体现出了这种同步。</p><p>在我看来，同步这个字眼更能体现git设计的初衷 —— 分布式版本控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了几遍廖雪峰的git教程和阮一峰的git教程之后，觉得自己使用git已经是得心应手了，脑中也构建出了一副关于git操作的图像。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习一个新东西的时候我总是喜欢把知识形象化出一个图谱在脑中，这样记忆的更加深刻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是随着使用的深入，我发现我脑中的图像与git的实际行为存在出入。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写更具有描述性的 RESTful API</title>
    <link href="http://beian.miit.gov.cn/posts/writing-more-descriptive-restful-api.html"/>
    <id>http://beian.miit.gov.cn/posts/writing-more-descriptive-restful-api.html</id>
    <published>2018-04-01T07:36:09.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>我时常觉得后端应该关心的是数据，而不是业务。<br>因此我希望能够在数据的基础上编写一套接口 能够满足h5端、pc端、ios/android端、包括小程序端等等80%的需求</p><a id="more"></a><p>laravel + dingo/api 对于api开发来说已经足够友好了，因此选择在它的基础上构建。</p><p>预备的知识</p><ul><li>laravel</li><li>RESTful</li><li>dingo/api</li></ul><h2 id="查询Filter"><a href="#查询Filter" class="headerlink" title="查询Filter"></a>查询Filter</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序字段的选择在网上有很多种</p><ol><li><code>?sort_field=created_at&amp;sort_order=asc</code> </li><li><code>?order=+created</code></li><li><p><code>?sort_by=created_at&amp;order=asc</code><br>…</p><p>这里选择在第三种方式,在可读性和数据处理上更加方便</p></li></ol><p><strong>url：</strong> <code>http://api.test/api/posts?sort_by=created_at&amp;order=desc</code></p><p><strong>laravel：</strong> <code>$query-&gt;orderBy(request()-&gt;get(&#39;sort_by&#39;, &#39;id&#39;), request()-&gt;get(&#39;order&#39;, &#39;desc&#39;))</code></p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>对于分页来说 <code>offset/limit</code>和<code>page/per_page</code> 又是两个纠结的选择<br>常见的分页需求有两种，一种时普通的ajax分页，另外一种是下拉加载更多分页<br>ajax分页相比于加载更多 通常需要一个total</p><p>因此选择能同时适应两种分页需求的 <code>page/per_page</code>，laravel和dingo/api对该方式的支持也足够好</p><p><strong>url：</strong> <code>http://maxwei.me/api/posts?per_page=3&amp;page=2</code></p><p><strong>laravel：</strong> <code>$query-&gt;paginate(request()-&gt;get(&#39;per_page&#39;, 15))-&gt;appends(request()-&gt;except(&#39;page&#39;))</code></p><p><strong>返回结果中的links示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;links&quot;: &#123;</span><br><span class="line">        &quot;next&quot;: &quot;http://api.test/api/posts?order=asc&amp;page=3&quot;,</span><br><span class="line">        &quot;previous&quot;: &quot;http://mp.test/api/diaries?order=asc&amp;page=1&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="字段筛选"><a href="#字段筛选" class="headerlink" title="字段筛选"></a>字段筛选</h3><p><strong>api：</strong> <code>api.test/users?fields=id,nickname,avatar</code> 对于user表中的phone，password字段推荐使用Model的hidden属性隐藏。<br><strong>laravel：</strong> <code>!is_null(request()-&gt;get(&#39;fields&#39;)) &amp;&amp; $query-&gt;addSelect(explode(&#39;,&#39;, request()-&gt;get(&#39;fields&#39;)));</code></p><p>transform()的常用写法和fields有一定的冲突，还没有找到比较优雅的解决方案。</p><h3 id="where筛选"><a href="#where筛选" class="headerlink" title="where筛选"></a>where筛选</h3><p>当我们只想要状态为1的文章时 我希望可以这么做<br><strong>url：</strong> <code>http://api.test/api/posts?status=1</code></p><p>当我想要标签id为1, 2的文章时则这样<br><strong>url：</strong> <code>http://api.test/api/posts?tag_id=1,2</code></p><p>当我… 够了，简单点是我所追求的，我不希望去创建一些规则满足模糊查询、notIn、orWhere、嵌套where等等。这不具有通用性，如果需要可以创建一些特定的路由去满足这些条件即可。</p><p><strong>laravel:</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$where = [<span class="string">'status'</span>, <span class="string">'tag_id'</span>] <span class="comment">//这是我希望能够被筛选的字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($where <span class="keyword">as</span> $item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null($value = request()-&gt;get($item))) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str_contains($value, <span class="string">','</span>)) &#123;</span><br><span class="line">        $query-&gt;whereIn($item, explode(<span class="string">','</span>, $value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $query-&gt;where($item, <span class="string">'='</span>, $value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源嵌套"><a href="#资源嵌套" class="headerlink" title="资源嵌套"></a>资源嵌套</h2><p>有如下两种需求场景</p><ul><li>获取某个用户/或标签下的所有文章</li><li>获取首页的精选文章</li></ul><p>我希望这两种情况都能通过一个index()方法得到解决，因此我这样做</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#api.php</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 主资源路由 </span></span><br><span class="line"> $api-&gt;resource(<span class="string">'posts'</span>, <span class="string">'PostController'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多对多关系嵌套路由</span></span><br><span class="line"> $api-&gt;get(<span class="string">'tags/&#123;tag&#125;/posts'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</span><br><span class="line">     $tags = \App\Models\Tag::findOrFail($id);</span><br><span class="line">     <span class="keyword">return</span> app()-&gt;call(<span class="string">'App\Http\Controllers\Api\PostController@index'</span>, [<span class="string">'query'</span> =&gt; $tags-&gt;posts()]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 一对多关系嵌套路由</span></span><br><span class="line"> $api-&gt;get(<span class="string">'users/&#123;user&#125;/posts'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</span><br><span class="line">     $user = \App\Models\User::findOrFail($id);</span><br><span class="line">     <span class="keyword">return</span> app()-&gt;call(<span class="string">'App\Http\Controllers\Api\PostController@index'</span>, [<span class="string">'query'</span> =&gt; $user-&gt;posts()]);</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 上面的代码非常的有规律，可以进行一次封装，而不是这样不行的重复解析。laravel5.6支持的路由模型注入是个不错的注意，但是dingo/api目前还不支持</span></span><br><span class="line"> <span class="comment">// 别忘了在你模型中定义相应的关联关系</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># PostController.php</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">($query = null)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// parseFilter是我封装的一个用来解析通用参数的方法</span></span><br><span class="line">     $paginator = <span class="keyword">$this</span>-&gt;parseFilter($query ?? Post::query());</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;paginator($paginator, <span class="keyword">new</span> PostTransformer());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="资源关联"><a href="#资源关联" class="headerlink" title="资源关联"></a>资源关联</h2><p>dingo/api + Fractal 对资源关联处理非常优雅，并且很好的解决了n+1 问题。</p><p>假设两个需求</p><ul><li>当我取出多个文章资源时我希望能够关联它们的作者。</li></ul><p><strong>url：</strong> <code>http://api.test/posts?include=user:field(id|name|avatar)</code></p><ul><li>取出一个社区资源并附带几名活跃的用户资源，以及这些活跃用户最近发表过的3篇文章时<br><strong>url：</strong> <code>http://api.test/hubs/1?include=hot_users:limit(3).posts:fields(id|title):limit(3)</code></li></ul><p>这大概就是我非常喜欢fractal而迟迟不肯使用laravel5.5的resources的原因， 因为它制定出了一套include的规则和相应的代码处理，使得代码的偶合性非常低。</p><blockquote><p>include参数的详细使用方式 请参考dingo/api文档 和 fractal文档 <a href="https://fractal.thephpleague.com/" target="_blank" rel="noopener">https://fractal.thephpleague.com/</a></p></blockquote><p>对于上面的需求我们可以这么做</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeUser</span><span class="params">(Post $post, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// fractal会帮我们解析include中的参数，并注入到 $params中。因此我们直接使用</span></span><br><span class="line">    $user = $post-&gt;user()-&gt;select($params[fields] ?? <span class="string">'*'</span>)-&gt;firstOrFail();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;item($user, <span class="keyword">new</span> UserTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># HubTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeHotUsers</span><span class="params">(Hub $hub, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $users = $hub-&gt;hot_users()</span><br><span class="line">        -&gt;limit($params[<span class="string">'limit'</span>][<span class="number">0</span>] ?? <span class="number">5</span>)</span><br><span class="line">        -&gt;get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;collection($users, <span class="keyword">new</span> UserTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># UserTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includePosts</span><span class="params">(User $user, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $post = $user-&gt;posts()</span><br><span class="line">        -&gt;select($params[fields] ?? [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'like_count'</span>])</span><br><span class="line">        -&gt;limit($params[<span class="string">'limit'</span>][<span class="number">0</span>] ?? <span class="number">5</span>)</span><br><span class="line">        -&gt;get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;collection($posts, <span class="keyword">new</span> PostTransformer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一下， 对于使用了 <code>$this-&gt;response()-&gt;collection()</code>和<code>$this-&gt;response-&gt;paginator()</code> 方法的资源。 dingo/api 会去解析url中的include参数，然后去调用模型的相应的关联方法来进行预加载，从而解决查询的n+1问题</p><p>上面的第二个需求，要求Hub模型中必须定义 hot_users和posts 这两个关联方法，否则就会抛出异常</p><blockquote><p>这里模型定义的关联方法的名称必须与url一致 既 hot_users()。非常难受呀，因为url推荐小写，方法名推荐小驼峰！！</p></blockquote><h3 id="关联资源的参数过滤规则"><a href="#关联资源的参数过滤规则" class="headerlink" title="关联资源的参数过滤规则"></a>关联资源的参数过滤规则</h3><p><code>:参数名称(值1|值2|值N)</code><br>‘:’ 冒号标志着一个参数的开始<br>紧跟着是参数名称<br>然后接上参数值 其中参数的值需要被括号括起<br>多个参数值时使用 ‘|’ 分隔</p><blockquote><p>关联资源我并不推荐提供分页参数，因为其会造成数据的重复读取，如果需要取出的关联资源数据量很多。推荐通过单独的api请求获取该资源，而不是通过include方式加载进来。</p></blockquote><h2 id="资源中的动作"><a href="#资源中的动作" class="headerlink" title="资源中的动作"></a>资源中的动作</h2><p>我们对资源存在一些动作行为，如对帖子的点赞收藏等，这里我选择模仿github的做法，将动作转换为资源。</p><h3 id="创建与删除动作资源"><a href="#创建与删除动作资源" class="headerlink" title="创建与删除动作资源"></a>创建与删除动作资源</h3><ul><li>点赞文章</li></ul><p><strong>url:</strong> <code>http://mp.test/posts/1/likes</code><br><strong>method:</strong> <code>POST</code></p><ul><li>取消点赞文章</li></ul><p><strong>url:</strong> <code>http://mp.test/posts/1/likes</code><br><strong>method:</strong> <code>DELETE</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostLikeController.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request, $id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB::table(<span class="string">'user_like_post'</span>)-&gt;insert([</span><br><span class="line">        <span class="string">'user_id'</span> =&gt; \Auth::id(),</span><br><span class="line">        <span class="string">'post_id'</span> =&gt; $id</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;created();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">destroy</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB::table(<span class="string">'user_like_post'</span>)-&gt;where(<span class="string">'user_id'</span>, \Auth::id())-&gt;where(<span class="string">'post'</span>, $id)-&gt;delete();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;noContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证动作资源"><a href="#验证动作资源" class="headerlink" title="验证动作资源"></a>验证动作资源</h3><p>这是一个我研究/纠结了很久的问题，尝试过很多种写法，这里决定模仿知乎的api写法</p><p>验证用户是否点赞了某一篇帖子</p><p><strong>url：</strong> <code>http://api.test/posts/1?include=is_like</code></p><p>对于上面的url，dingo/api 会自动调用PostTransformer的includeIsLike方法。我们只需要在该方法中进行验证即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeIsLike</span><span class="params">(Post $post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这行代码可以根据Auth::id Cache一下</span></span><br><span class="line">    $likePostIds = DB::table(<span class="string">'user_like_post'</span>)-&gt;where(<span class="string">'user_id'</span>, Auth::id())-&gt;pluck(<span class="string">'post_id'</span>)-&gt;toArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;primitive(in_array($diary-&gt;id, $likePostIds));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吐槽一下 includeIsLike如何返回标量资源，文档上没有任何描述。<br>看了源码才发现primitive这个关键词。😣</p><p>对于单个资源可以很容易的完成上面的需求，但对于资源集合我遇到了很大的问题</p><p><strong>url：</strong> <code>http://api.test/posts?include=is_like</code></p><p>集合我统一使用了<code>$this-&gt;response-&gt;paginator()</code>， 前面提到 paginator和collection方法，会去检测include参数并调用模型的相应的关联方法来进行预加载。 所以会去posts模型去找is_like方法，可是我真的定义不出一个is_like关联关系呢。<br>而且这个行为是没法优雅的禁止掉的，想要禁止？ok啊，那就全关了，别想我再给你解决n+1问题了</p><p>这明明是一个很容易解决的问题，在dingo/api的issue中也提到了多次。但是都没有得到解决。</p><blockquote><p>于是我fork下了dingo/api的代码准备解决一下这个问题时，我终于明白是为什么了~<br>dingo/api和Fractal是不同作者的项目。dingo/api是为laravel量身打造的。其依赖的transform使用的是Fractal。 而Fractal并不专属于laravel.<br>在dingo/api中做很容易，但是在Fractal中添加一个为laravel服务的扩展就有些不切实际了</p></blockquote><p>既然如此就在我们的项目中稍微解决一下这个问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个根Transformers.php 所有的Transformer都继承自该Transformer</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Transformers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">TransformerAbstract</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span> <span class="keyword">extends</span> <span class="title">TransformerAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $disableEagerLoadedIncludes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDisableEagerLoadedIncludes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;disableEagerLoadedIncludes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Fractal.php 并继承于原有Fractal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fractal</span> <span class="keyword">extends</span> \<span class="title">Dingo</span>\<span class="title">Api</span>\<span class="title">Transformer</span>\<span class="title">Adapter</span>\<span class="title">Fractal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeEagerLoads</span><span class="params">($transformer, $requestedIncludes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $includes = array_merge($requestedIncludes, $transformer-&gt;getDefaultIncludes());</span><br><span class="line">        $includes = array_diff($includes, $transformer-&gt;getDisableEagerLoadedIncludes());</span><br><span class="line">        $eagerLoads = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($includes <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            $eagerLoads[] = is_string($key) ? $key : $value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $eagerLoads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 dingo/api的配置文件api.php 将原有的Fractal更改为我们自定义的</span></span><br><span class="line"></span><br><span class="line"><span class="string">'transformer'</span> =&gt; env(<span class="string">'API_TRANSFORMER'</span>, \App\Services\Fractal::class),</span><br></pre></td></tr></table></figure><p>大功告成~ 接下来我们只需要在PostTransformer中定义一个 disableEagerLoadedIncludes属性来添加不需要急切加载的属性了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $disableEagerLoadedIncludes = [<span class="string">'is_like'</span>];</span><br></pre></td></tr></table></figure><p>终于可以  <code>?include=is_like,like_count,is_author,balala...</code> 面向include的编程了</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面说的都是已查询为主，但增删改也有一些小技巧 如创建资源除了使用 dingo/api封装的<code>$this-&gt;response-&gt;created()</code>外， 使用<code>$this-&gt;response-&gt;item($post, new PostTransformer())-&gt;setStatusCode(201);</code>也是一种不错的选择。</p><p>使用 request进行表单验证、使用 Policiy进行权限验证、使用Observer进行副作用的处理等等，从而保证增删改的代码更具有可读性和解耦性。</p><p>另外还有很多待解决的问题</p><ul><li>如嵌套资源中，直接在路由文件中处理逻辑并不优雅</li><li>fields 筛选字段对 Transform的传统写法并不友好 有待改进</li><li>fields方法在laravel中显得和include有些冲突，是否可以直接在include中编写需要获取的fields呢<ul><li>这里我觉得可能需要抛弃原有transform()的写法，数据处理应该通过orm提供的一些修改器来进行。更多的数据处理则交给客户端，服务端提供一些更加raw的数据。</li></ul></li><li><p>当一个界面过于复杂时，需要请求多次api，超过3次以上我就有些难以接受了，get请求url过长问题，接下来会尝试进行路由的映射 组装操作等操作解决这个问题</p></li><li><p>资源暴露是否会带来安全问题？这一点我觉不会。如何认证和限流参考dingo/api文档即可</p></li><li>对于一些不符合RESTful资源的需求如何处理，如搜索需求。可以尝试创建些额外的路由来处理这些额外的需求。这些需求可以占到一个项目的20%左右</li><li>资源控制器的index方法使用的page每次都会多查询一条总记录数的sql。</li><li><p>资源控制器的index方法如果不存在筛选条件时如何做资源限制，总不能一次取出所有的资源</p><ul><li><p>突发奇想采用了一个sql黑名单的机制</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">isBlacklist</span><span class="params">($query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $limit = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request(<span class="string">'per_page'</span>) &amp;&amp; request(<span class="string">'per_page'</span>) &lt; $limit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $key = <span class="string">'sql:'</span>. $query-&gt;toSql();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Cache::has($key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($query-&gt;count() &gt; $limit) &#123;</span><br><span class="line">                Cache::forever($key, date(<span class="string">'Y-m-d H:i:s'</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>…</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>再次说明一下我在做什么，我希望能够在数据的基础上编写一套接口能够满足h5端、pc端、ios/android端、包括小程序端等等80%的需求。<br>我不希望我的接口要跟着每一次的业务变动而去修改，我希望自己关心的是数据，而不是业务。<br>我希望只要知道产品的原型，就能完成后端80%的开发， 而不是等设计定稿/等前端开发等等</p><p>现在前端的开发是模块化的，在我看来就是面向import的开发。<br>传统的RESTful接口没法适应于前端的模块化开发。存在着大量的字段冗余和http请求，这是我在学习graphQL的时看到的一句话。</p><p>但既然前端的开发是模块化的、面向import的，后端的api接口为什么不能是面向include的呢 😆</p><blockquote><p>持续关注中 - 希望你能分享在RESTful API、dingo/api、laravel api等开发时的经验、想法和技巧~<br>我将会总结出一份代码demo并分享出来</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我时常觉得后端应该关心的是数据，而不是业务。&lt;br&gt;因此我希望能够在数据的基础上编写一套接口 能够满足h5端、pc端、ios/android端、包括小程序端等等80%的需求&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解TCP协议（一）</title>
    <link href="http://beian.miit.gov.cn/posts/a-deep-understanding-of-the-tcp-protocol-1.html"/>
    <id>http://beian.miit.gov.cn/posts/a-deep-understanding-of-the-tcp-protocol-1.html</id>
    <published>2018-02-09T15:39:24.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="三路握手"><a href="#三路握手" class="headerlink" title="三路握手"></a>三路握手</h2><ol><li><p>服务器端通过调用 socket、bind和1isten这3个函数准备好接受外来的连接。称之为被动打开（passive open）</p></li><li><p>客户端通过调用 connect发起主动打开( active open)。该调用使客户端发送一个SYN(同步)分节给服务器，SYN中包含客户将在(待建立的)连接中发送的数据的初始序列号。<strong>通常SYN分节不携带数据</strong>， 其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。</p></li><li>服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK(确认)。</li><li>客户必须确认服务器的SYN。既发送一个确认SYN的ACK。</li></ol><p>这种交换至少需要3个分组,因此称之为TCP的三路握手(thre-way handshake)。<br><img src="http://asset.eienao.com/15175486060759.jpg" alt></p><p>可以看到服务端调用accept()函数后，一直处于阻塞状态。直到三路握手完成后，accept函数才返回。然后再阻塞于read状态</p><h2 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h2><p>TCP为一个连接定义了11种状态</p><p><img src="http://asset.eienao.com/15179303680473.jpg" alt></p><p>其中ESTABLISHED为（客户端或服务端）完成三路握手后的状态，这个最终状态在数据发送期间一直保持。</p><p>主动调用close一方经历了TIME_WAIT状态，  在TIME_WAIT状态下会持续 2MSL (时间单位)。<br><strong>MSL: maximum segment lifetime</strong><br>实现TCP时必须必须为MSL选择一个值，建议在30秒~2分钟。<br>MSL是任何IP数据报能够在因特网中存活的最长时间。</p><p>TIME_WAIT状态有两个存在的理由：<br>(1)可靠地实现TCP全双工连接的终止<br>(2)允许老的重复分节在网络中消逝，因为TCP协议规定在TIME_WAIT状态下的一端不允许创建新的TCP连接。从而保证旧连接的任何分节都不会发送到新的连接中去（分节在因特网中的最长存活时间小于TIME_WAIT持续的时间）。</p><p><img src="http://asset.eienao.com/15179304017422.jpg" alt></p><p>上图服务器对客户的请求的确认是伴随其应答发送的,这种做法称为 piggybacking，<br>它通常在服务器请求并产生的应答的时间少于200ms时发生。</p><h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p><img src="http://asset.eienao.com/15181013775313.jpg" alt><br>如图为一个多进程模型的并发服务器</p><p>我们发现子进程1和子进程2的connect_socket甚至是listen_socket都使用了服务器端的21端口。</p><p>当客户端请求12.106.32.254:21端口时，tcp协议应该将该请求交给三个socket中的哪一个呢？</p><p>首先通过上图可以确定的是无法仅仅通过目的端口将到来的请求交给对应的socket。</p><p><strong>书（unix网络编程卷3）中的解释是：</strong>  TCP协议必须查看<strong>套接字对</strong>的所有四个元素，才能确定由哪个socket接受到达的客户端请求。</p><blockquote><p>对于tcp请求，我们可以在分节的tcp标头中得到这四个元素（请求双方的id和端口号）<br><img src="http://asset.eienao.com/15181892735181.jpg" alt></p></blockquote><p><strong>下面是我根据书中的解释做出的臆想</strong></p><p>对于一台并发服务器来说，一个简单的算法是：对于一个到来的分节。首先查看其目的端口(对于单ip服务器来说，再查看分节的目的ip就有些多此一举了)。</p><p>然后检索所有监听了该目的端口的socket。假如只检索到一个，那么直接将该分节交给该socket即可。</p><p>当检索出了多个socket时 (上图中多个已连接socket的情况)，我们可以根据客户端的ip与端口号进行匹配，当然这一次是客户端的ip与端口都需要参与匹配。<br>优先匹配具有精确客户端地址的socket 如服务器的子进程2的socket中保存的socket pair为 <code>{12.106.32.254:21,206.168.112.219:1501}</code><br>其精确的标识了请求端的ip地址和端口号 206.168.112.219:1501<br>其次再匹配通配的socket。如监听socket</p><p>当然要做到上面匹配需要我们服务器端的socket中保存了4个元素。实际上也确实如此</p><p>socket中包含的一个inet_sock的结构体如下。其中包含确定一个tcp连接所需的4个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inet_sock   </span><br><span class="line">&#123;   </span><br><span class="line">    struct sock sk;   </span><br><span class="line">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)   </span><br><span class="line">    struct ipv6_pinfo   *pinet6;   </span><br><span class="line">#endif   </span><br><span class="line">    __u32           daddr;          //IPv4的目的地址。   </span><br><span class="line">    __u32           rcv_saddr;      //IPv4的本地接收地址。   </span><br><span class="line">    __u16           dport;          //目的端口。   </span><br><span class="line">    __u16           num;            //本地端口（主机字节序）。  </span><br><span class="line">    </span><br><span class="line">    …………      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;三路握手&quot;&gt;&lt;a href=&quot;#三路握手&quot; class=&quot;headerlink&quot; title=&quot;三路握手&quot;&gt;&lt;/a&gt;三路握手&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务器端通过调用 socket、bind和1isten这3个函数准备好
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nuxt——服务端渲染可选方案</title>
    <link href="http://beian.miit.gov.cn/posts/nuxt-server-side-rendering-options.html"/>
    <id>http://beian.miit.gov.cn/posts/nuxt-server-side-rendering-options.html</id>
    <published>2018-01-27T12:54:45.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>团队在最近的一次开发中前端技术栈从html + css + jquery转向vue全家桶。后端从php + Blade + jquery转向vue全家桶。</p><p>在转向前后端分离的开发模式中遇到了一些问题。</p><ul><li>首屏加载缓慢</li><li>seo问题</li><li>前后端分离中的异步请求数量过多等问题</li></ul><p>为了解决上面的尤其是第二个问题。团队决定使用服务端渲染。</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>服务端渲染可以很好的解决打包文件过大导致的首次加载白屏问题，并且页面打开速度相比于js渲染界面快很多。</p><p>就像过去用php的模板引擎渲染html界面也是一种服务端渲染方式，但并不适用于大JavaScript时代了。</p><p>我最早看到服务端渲染是在淘宝博客的前后端分离的思考与实践中，他们提出了一个中途岛的概念。</p><blockquote><p>其实回头想想，在我们把渲染的工作从 服务端抽出来到 浏览器端（JS）的时候，我们的目的只是明确的前后端职责划分，并不是非浏览器渲染不可。</p><p>只是因为在传统的开发模式中，出了服务器就到了浏览器，所以前端的工作内容只能被限制在浏览器端。</p><p>也因此很多人认定了 后端 = 服务端 前端 = 浏览器端<br>                     ——前后端分离的思考与实践</p></blockquote><p><img src="https://gw.alicdn.com/tfs/TB1WEF2QpXXXXXvaXXXXXXXXXXX-572-145.png" alt="中途岛的概念"></p><p>原文链接 <a href="http://taobaofed.org/blog/2014/04/09/practice-of-separation-of-front-end-from-back-end-2/" target="_blank" rel="noopener">前后端分离的思考与实践（二）</a></p><hr><p>前后端分离是架构上的分离，并不是人员上的分离，php程序员写写现代js对自身的成长也是有很大帮助的。</p><p>其实我想说的是php并不是不可替代的😆，node.js什么嗒也是可以很好的完成web开发的</p><p>由于使用了vue全家桶，且对node.js也不是很熟悉，所以选择了nuxt.js服务端渲染框架 （主要还是用起来简单，学起来快）</p><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><p>nuxt中文文档 <a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">https://zh.nuxtjs.org/guide</a></p><p><img src="https://zh.nuxtjs.org/nuxt-schema.png" alt></p><p>在使用nuxt的过程中，我们对一个界面的请求方式有两种。</p><ul><li>从浏览器地址栏键入</li><li>通过类似 router-link的a标签点击跳转</li></ul><p>当我们从浏览器的地址栏中键入一条请求时，请求被交给了nuxt服务器（或者nginx→nuxt）。<br>nuxt服务器解析vue组件（中的asyncData方法），并将数据绑定到html。然后再返回给浏览器。</p><p>当我们通过点击router-link跳转时整个应用依旧是无刷新的单页应用。且会在window.history中键入记录。</p><p>因此对于任意一个vue组件其被访问的情况分为两种，浏览器端渲染和nuxt服务器端渲染。</p><p>了解nuxt最快的方式就是了解nuxt的生命周期，了解nuxt生命周期最快的方式自然是conlose.log()了。<br>并不具体的细节请参考手册。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>nuxt项目还比较年轻，所以存在一些莫名奇妙的bug（更多的bug主要是对js不熟悉所致）。<br>但是vue官方推荐，且有着强大的社区支撑，所以还是有着不错的维护效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;团队在最近的一次开发中前端技术栈从html + css + jquery转向vue全家桶。后端从php + Blade + jquery转向vue全家桶。&lt;/p&gt;
&lt;p&gt;在转向前后端分离的开发模式中遇到了一些问题。&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简述 container —— 反射机制实现</title>
    <link href="http://beian.miit.gov.cn/posts/a-brief-introduction-to-the-realization-of-container-reflection-mechanism.html"/>
    <id>http://beian.miit.gov.cn/posts/a-brief-introduction-to-the-realization-of-container-reflection-mechanism.html</id>
    <published>2018-01-27T09:00:03.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>使用依赖注入实现控制反转来降低代码的耦合性。</p></blockquote><p>依赖注入 DI，控制反转 IOC，解耦等等等 大家探索前进，终走到了这一步,终于让代码灵活、可扩展、低耦合、高内聚，终于可以开心的coding了!!</p><p>好，现在我要去数据库中查询用户id为1的用户名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> User(</span><br><span class="line">    <span class="keyword">new</span> \Database\MysqlDrive(<span class="keyword">new</span> \Database\Connection),</span><br><span class="line">    <span class="keyword">new</span> Builder(),</span><br><span class="line">    <span class="keyword">new</span> Relations(),</span><br><span class="line">    <span class="keyword">new</span> Event(<span class="keyword">new</span> Listener()),</span><br><span class="line">    <span class="keyword">new</span> Auth(),</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">stop？我好像有点写不完，我只想获取一个用户名而已！！！</span><br></pre></td></tr></table></figure><p>当我使用依赖注入后，所有的依赖都由调用者来处理， 调用者可以控制User的行为，但却要做更多的事情。</p><p>但我不想多做一丝事情，我希望更加简单，简单到连依赖也能自动处理，解析，自动注入该有多好呀！</p><blockquote><p>题外话：我所理解的最为灵活的php开发架构是，php作为一个中转，将前端和mysql连接起来。这样我们就可以灵活到一套代码解决所有所有的问题了。<br>例如<code>http://web.dev/users/1?fields=id,username&amp;include=posts:limit(1|5):order(created_at|desc)</code></p></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我现在有一个Foo类，Foo类中一个<code>allBarName()</code>方法.并且依赖于BarA~BarD这4个类的name()方法. 如下 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Container</span>\<span class="title">Foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Container</span>\<span class="title">Bar</span>\<span class="title">BarA</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Container</span>\<span class="title">Bar</span>\<span class="title">BarB</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Container</span>\<span class="title">Bar</span>\<span class="title">BarC</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Container</span>\<span class="title">Bar</span>\<span class="title">BarD</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $barA;</span><br><span class="line">    <span class="keyword">private</span> $barB;</span><br><span class="line">    <span class="keyword">private</span> $barC;</span><br><span class="line">    <span class="keyword">private</span> $barD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BarA $barA, BarB $barB, BarC $barC, BarD $barD)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;barA = $barA;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;barB = $barB;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;barC = $barC;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;barD = $barD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">allBarName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;barA-&gt;name().<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;barB-&gt;name().<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;barC-&gt;name().<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;barD-&gt;name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BarA示例， BarB，BarC，BarD相同</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Container</span>\<span class="title">Bar</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'彼得·帕克'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用依赖注入的方式来，调用<code>allBarName()</code>方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="keyword">new</span> \Container\Foo\Foo(</span><br><span class="line">    <span class="keyword">new</span> \Container\Bar\BarA(),</span><br><span class="line">    <span class="keyword">new</span> \Container\Bar\BarB(),</span><br><span class="line">    <span class="keyword">new</span> \Container\Bar\BarC(),</span><br><span class="line">    <span class="keyword">new</span> \Container\Bar\BarD()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $foo-&gt;allBarName(); <span class="comment">// 彼得·帕克/托尼·屎大颗/巴里·艾伦/布鲁斯·韦恩</span></span><br></pre></td></tr></table></figure><p>上面的code已经是低耦合的了。<br>但懒惰的我并不想去手动注入Foo的所有依赖，我希望能有一个Container来帮我解析Foo的所有依赖，然后再把实例返回给我。</p><p>那就来吧，实现一个简单的Container</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Container</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $reflection = <span class="keyword">new</span> \ReflectionClass($class);</span><br><span class="line"></span><br><span class="line">        $constructor = $reflection-&gt;getConstructor();</span><br><span class="line">        $parameters = $constructor-&gt;getParameters();</span><br><span class="line"></span><br><span class="line">        $instances = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($parameters <span class="keyword">as</span> $parameter) &#123;</span><br><span class="line">            $className =  $parameter-&gt;getClass()-&gt;getName();</span><br><span class="line">            $instances[] = <span class="keyword">new</span> $className;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 将数组拆封成参数传递给方法, 类似于 call_user_func_array()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> $class(...$instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单到不能再简单的依赖解析容器了，但我想它能满足我的需求。</p><p>再次调用allBarName()方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$foo = \Container\Container::make(\Container\Foo\Foo::class);</span><br><span class="line"><span class="keyword">echo</span> $foo-&gt;allBarName(); <span class="comment">// 彼得·帕克/托尼·屎大颗/巴里·艾伦/布鲁斯·韦恩</span></span><br></pre></td></tr></table></figure><p>oh yeah！成功了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我想我已经表达了我的想法，我还没有能力也不是很想去实现一个强大灵活的container，能够知道为什么需要container我已经很满足了。</p><ul><li>code demo <a href="https://github.com/weiwenhao/container" target="_blank" rel="noopener">https://github.com/weiwenhao/container</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用依赖注入实现控制反转来降低代码的耦合性。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决Chrome6.2以上Preview无法渲染js问题</title>
    <link href="http://beian.miit.gov.cn/posts/chrome62-above-to-solve-the-problem-can-not-render-js.html"/>
    <id>http://beian.miit.gov.cn/posts/chrome62-above-to-solve-the-problem-can-not-render-js.html</id>
    <published>2017-12-26T17:31:19.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="http://omjq5ny0e.bkt.clouddn.com/17-12-23/6366700.jpg" alt><br>既该界面无法渲染dump()或者dd()</p><blockquote><p>chrom版本: 63.0.3239.84<br>系统版本:  os10.12</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>当响应的状态码为400 or 500系列时可以使Preview渲染</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_response_code(<span class="number">500</span>); <span class="comment">// or 400系列状态码</span></span><br><span class="line">dd(request());</span><br></pre></td></tr></table></figure><p><img src="http://omjq5ny0e.bkt.clouddn.com/17-12-23/14918492.jpg" alt></p><p>寻求方便的话,可以将上面的代码添加到 live templates中,或者添加一个helper function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ddd(...$args)&#123;</span><br><span class="line">    http_response_code(500);</span><br><span class="line">    call_user_func_array(&apos;dd&apos;, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果服务端响应的数据过大时Preview可能会出现 <code>failed to load response data</code> 这样的错误.<br>并没有找到确切的解决办法,可以尝试变更http响应的状态码为400解决该问题.</p><p>参考链接: <a href="https://github.com/symfony/symfony/issues/24688" target="_blank" rel="noopener">https://github.com/symfony/symfony/issues/24688</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://omjq5ny0e.bkt.clouddn.com/1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简述python异步i/o库 —— asyncio</title>
    <link href="http://beian.miit.gov.cn/posts/python-asyncio.html"/>
    <id>http://beian.miit.gov.cn/posts/python-asyncio.html</id>
    <published>2017-10-31T08:12:02.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>python的asyncio库以协程为基础，event_loop作为协程的驱动和调度模型。该模型是一个单线程的异步模型，类似于node.js。下图我所理解的该模型</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/10/31/23b17e8d92ec76fcefb7abadc0101dd7" alt></p><p>事件循环通过select()来监听是否存在就绪的事件，如果存在就把事件对应的callback添加到一个task list中。然后从task list头部中取出一个task执行。在单线程中不断的注册事件，执行事件，从而实现了我们的event_loop模型。</p><p><strong>event_loop中执行的task并不是函数</strong></p><p>如果<strong>我们把上图当成一个web服务器</strong>，左边的一个task当成一次http请求需要执行的完整任务。如果我们每一次run_task()都执行完一个完整的任务，再去run下一个task。 那这跟普通的串行服务器并没有区别。在并发环境下造成的用户体验非常差。</p><blockquote><p>具体怎么差你可以脑补一下，毕竟我们现在是使用单线程方式实现的web服务器</p></blockquote><p>所以task如果对应一个完整的http请求那么其不可能是一个函数，因为函数需要从头执行到尾占用着整个线程。那你觉得task是什么呢？</p><p>如果你不知道答案的话可以看一看我的另一篇文章 <a href="http://www.weiwenhao.xyz/article/the-yield-and-yield-of-python-the-from" target="_blank" rel="noopener">简述python的yield和yield from</a></p><p>没错，task是一个generator，或者可以叫做可中断的函数。task的代码依旧是从上写到下来处理一个http请求。也就是我们所说的同步的代码组织。</p><p>但是有所不同的是，在task中，我们遇到i/o操作时，我们就把i/o操作交给selector（稍后我们解析一下selector，并且把该i/o操作准备完毕后需要执行的回调也告诉selector。然后我们使用yield保存并中断该函数。</p><p>此时线程的控制权回到event_loop手中。event_loop首先看一下selector中是否存在就绪的数据，存在的话就把对应的回调放到task list的尾部（如图），然后从头部继续run_task()。</p><p>你可能想问上面中断的task什么时候才能继续执行呢？我前一句说过了，event_loop每一次循环都会检测selector中是否存在就绪的i/o操作，如果存在就绪的i/o操作，我们对应就把callback放到task的尾部，当event_loop执行到这个task时。我们就能回到我们刚刚中断的函数继续执行啦，而且此时我们需要的i/o操作得到的数据也已经准备好了。</p><blockquote><p>这种操作如果你站在函数的角度会有种神奇的感觉，在函数眼里，自己需要get遥远服务器的一些数据，于是调动get()，然后瞬间就得到了遥远服务器的数据。没错在函数的眼里就是瞬间得到，这感觉就仿佛是穿越到了未来一样。</p></blockquote><p>你可能又想问，为什么把callback放到task，然后run一下就回到原有的函数执行位置了？</p><p>这我也不知道，我并没有深追asyncio的代码，这对于我来说有些复杂。但如果是我的话，我只要在callback中设置一个变量gen指向我们的generator就行了，然后只要在callback中<code>gen.send(res_data)</code>，我们就能回到中断处继续执行了。如果你有兴趣的话可以自己使用debug来追一下代码。</p><p>不过我更推荐你阅读一下这篇博文 <a href="http://python.jobbole.com/88291/" target="_blank" rel="noopener">深入理解 Python 异步编程(上)</a></p><h3 id="这里还有几个问题。"><a href="#这里还有几个问题。" class="headerlink" title="这里还有几个问题。"></a>这里还有几个问题。</h3><p>比如我们在task中需要执行一个1+2+3+到2000万这样一个操作，这个操作耗时有些长，而且不属于i/o操作，没法交给selector去调度，此时我们需要自己yield，让其他的task能有机会来使用我们唯一的线程。这样就又有一个新的问题。yield后，我们什么时候再次来执行这个被中断的函数呢？</p><p>问题代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">()</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">20000000</span>):</span><br><span class="line">        sum += a</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">1000000</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">'1+到2000万的和是&#123;&#125;'</span>.format(sum))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> print_sum()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init())</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure><p>我想我们可以这样，把这个中断的task直接加入到task list的尾部，然后继续event_loop，这样让其他task有机会执行，并且处理起来更加的简单。 asyncio库也确实是这样做的。</p><p><em>但是asyncio还提供了更好的做法，我们可以再启动一个线程来执行这种cpu密集型运算</em></p><hr><p>再来看看另外一个问题。如果在一个凌晨三点半，你task list此时是空的，那么你的event_loop怎么运作？继续不停的loop等待新的http请求进来？ no，我们不允许如此浪费cpu的资源。asyncio库也不允许。</p><p>首先看两行event_loop中的代码片段，也就是上图中右上角部分的select(timeout)部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event_list = self._selector.select(timeout)</span><br><span class="line">   self._process_events(event_list)</span><br></pre></td></tr></table></figure><blockquote><p>补充一点，作为一台web服务器，我们总是需要socket()、bind()、listen()、来创建一个监听描述符sockfd，用来监听到来的http请求，与http请求完成三路握手。然后通过accept()操作来得到一个已连接描述符connectfd。</p><p>这里的两个文件描述符，此时都存在于我们的系统中，其中sockfd继续用来执行监听http请求操作。已经连接了的客户端我们则通过connectfd来与其通信。一般都是一个sockfd对多个connectfd。</p><p>更多的细节推荐阅读  ——《unix网络编程卷一》中的关于socket编程的几章</p></blockquote><p>asyncio对于网络i/o使用了 selector模块，selector模块的底层则是由 epoll()来实现。也就是一个同步的i/o复用系统调用<strong>（你定会惊讶于asyncio的竟然使用了同步i/o来实现？我们在下一节来解读一下epoll函数）</strong></p><p><em>这里你可以去读一下python手册中的selector模块，看看这个模块的作用</em></p><p>epoll()函数有个timeout参数，用来控制该函数是否阻塞，阻塞多久。映射到高层就是我们上面的<code>selector.select(timeout)</code>中的timeout。原来我们的event_loop中的存在一个timeout。这样凌晨三点半我们如何处理event_loop我想你已经心里有数了吧。</p><p>asyncio的实现和你想的差不多。如果task list is not  None那么我们的timeout=0也就是非阻塞的。解释一下就是，我们调用selector.select(timeout = 0 )，该函数会马上返回结果，我们对结果做一个上面讲过的处理，也就是<code>self._process_events(event_list)</code>。然后我们继续run task。</p><p>如果我们的task list is None， 那么我们则把timeout=None。也就是设置成阻塞操作。此时我们的代码或者说线程会阻塞在selector.select(timeout = 0)处，换句话说就是等待该函数的返回。<strong>当然这样做的前提是，你往selector中注册了需要等待的socket描述符。</strong></p><hr><p>还有一些其他的问题，比如异步mysql是如何在asyncio的基础上实现的，这可能需要去阅读aiomysql库了。</p><p>你也许发现，我们一旦使用了event_loop实现单线程异步服务器，我们写的所有代码就都不是我们来控制执行了，代码的执行权全部交给了event_loop，event_loop在适当的时间run task。读过廖雪峰python教程的小伙伴一定看过这句话</p><blockquote><p>这就是异步编程的一个原则：一旦决定使用异步，则系统每一层都必须是异步，“开弓没有回头箭”。  </p></blockquote><p>这就是异步编程。</p><hr><p>你也许对asyncio的作用，或者使用，或者代码实现有着很多的疑问，我也是如此。但是很抱歉，我并不怎么熟悉python，也没有使用asyncio做过项目，只是出于好奇所以我对python的异步i/o进行了一个了解。</p><p>我是一个纸上谈兵的门外汉，到最后我也没能看清asyncio库的具体实现。我接下来的计划中并不打算对asyncio库进行更多的研究，但是我又不甘心这两天对asyncio库的研究付诸东流。所以我留下这篇博文，算是对自己的一个交待！希望下次能够有机会，能够更加了解python和asyncio的前提下，再写一篇深入解析python—asyncio的博文。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python的asyncio库以协程为基础，event_loop作为协程的驱动和调度模型。该模型是一个单线程的异步模型，类似于node.js。下图我所理解的该模型&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://beian.miit.gov.cn/categories/python/"/>
    
    
      <category term="asyncio" scheme="http://beian.miit.gov.cn/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>简述python的yield和yield from</title>
    <link href="http://beian.miit.gov.cn/posts/python-yield-from.html"/>
    <id>http://beian.miit.gov.cn/posts/python-yield-from.html</id>
    <published>2017-10-31T01:12:02.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>函数可以看成是一堆指令的集合。在函数中加入yield可以把一个函数变成一个generator，虽然调用的方式不一样了，但是其实现的功能和原来的函数基本是一样的。</p><a id="more"></a><p>而yield在这其中的作用是，把运行中的函数进行了一个保存退出（也就是中断）。然后把线程的的控制权从函数手里交换到我们手里(这样说很牵强，因为程序都是我们写的哈哈)， 我们可以在<strong>适当</strong>的时机在继续运行该函数。</p><p>函数运行过程中的中断操作在单线程中可以用来实现一些很神奇的功能。尤其是在网络i/o操作中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test():</span><br><span class="line">request_baidu_server(baidu_data)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(baidu_data)</span><br></pre></td></tr></table></figure><p><code>request_baidu_server(baidu_data)</code>去请求百度需要走很长的网络线路，三路握手,数据传递。这在cpu的感官里这就是等待数年的操作。我们的程序无法继续运行，难道我们就这样让cpu等待？当然不<br>所以调用yield把线程的控制权交出来，然后我们让线程去做一些其他的事情，比如再入请求新浪服务器。又要等待？ok，我们继续，就一瞬间，我们同时请求了上千台服务器的数据。这难道还不够神奇吗？</p><p><strong>稍微总结一下yield，通过其可以让我们程序员实现对线程的调配，从而更加充分的利用的们的cpu。</strong></p><p>上面的程序只是一个雏形，但是由于yield的功能比较简单，所以不赘述。至少要了解一下send()操作才能继续往下看。</p><h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><hr><p>一个函数不可能写几千行，通常都是 a调用b，b调用c， c调用a。这样会增加代码的可读性，复用性。</p><p>现在思考假如b()调用c()，c()中存在yield时我们应该如何处理？</p><p>我们可能需要这么处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">  gen = c()</span><br><span class="line">  r = gen.send(<span class="keyword">None</span>)</span><br><span class="line">  print(r)</span><br><span class="line">  r = gen.send(<span class="keyword">None</span>)</span><br><span class="line">  <span class="comment"># 或者用for gen in c()来进行生成器的运行，但是这样已经很麻烦了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>鉴于在生成器中调用生成器比较麻烦，所以有了yield from语法。用于简化嵌套调用生成器的语法复杂度，下面是一个示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">r = <span class="keyword">yield</span> <span class="keyword">from</span> c()</span><br><span class="line">    print(r) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">r = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(r) <span class="comment"># 哈哈</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gen = b()</span><br><span class="line">gen.send(<span class="keyword">None</span>) <span class="comment"># 1</span></span><br><span class="line">gen.send(<span class="string">'哈哈'</span>) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>当我们第一次调用send时，运行到语句 <code>yield from c()</code> 这条语句在我理解就是</p><p><code>gc = c(),res = gc.send(None),yield res</code> 执行了这三条语句.</p><p>但是，其中第二条指令<code>gc.send()</code>执行时，线程的控制权从b函数转移到了c函数。 所以<code>yield from c()</code>可以理解为保存并中断当前函数，然后把线程的控制权交给c函数。</p><p>此时线程执行c函数，函数执行了一条<code>r = yield 1</code>进行了保存退出，此时线程的控制权又再一次回到了我们手上。也就是<code>gen.send(None)</code>返回了结果1。</p><p>此时线程的控制权在我们手里，然后我们调用<code>gen.send(&#39;哈哈&#39;)</code>，又把线程的控制权交还给了c函数，线程来到c函数刚刚的退出点继续往下执行。</p><p>根据语法定义，<code>send(&#39;哈哈&#39;)</code>的参数将会作为yield的返回值。也就是<code>r = yield 1</code>中的<code>r</code>会收到字符串 ‘哈哈’。我们现在透过了b函数，直接和c函数进行了交互。我想这就是yield from最大的作用了!</p><p>我们继续往下走，此时c函数 <code>return 4</code> 这又会产生什么效果呢？你可以猜测一下。</p><p>说一下我的理解，c函数现在执行完毕，自然是回到调用处。也即是<code>r = yield from c()</code>，现在重新审视一下这条语句。b函数执行过程中需要c的结果，否则没有办法继续往下执行，所以把线程控制权交给了c。b经过了数年的等待终于等到了c的执行结果，也就是<code>return 4</code>中的4。此时4的值会赋给r。然后函数继续往下执行。这就和我们再普通函数a()中调用b()一样，只不过是在生成器调用生成器需要用到特殊的写法而已。</p><p>为什么需要yield from， 已经yield from的作用我想应该理解了吧~</p><blockquote><p>补充一句， 很多原理性的东西我其实不确定，以上只是我的感性的理解。比如4的值是如何赋给r我并不知道。我们是否是直接越过b函数和c函数进行交互，我也不确定。我目前没有能力进行更深层次的了解。</p></blockquote><p>再啰嗦一下~。上面的程序最后三行就像一个主控器一样，调控b()，c()函数的运行，并且远不止于此。我们可以运行一会c，运行一会b。运行一会d,e,f,g等等。 你也许会疑问这有什么意义？</p><p>在cpu密集型运算的程序中，这一点意义都没有。 但是在i/o密集型运算中，这样做的意义是非凡的。</p><p>当我们遇到需要长时间i/o等待时，就把线程的控制权交给下一个函数或者说http请求，长时间的i/o返回结果时， 我们我们在回到原有的程序。</p><p>这在cpu眼里是按顺序执行的，但在我们眼里确是单个线程同时处理着上千个请求，因为cpu的处理速度非常快。 i/o操作不止于网络i/o，还有文件读写i/o，数据库读写i/o。</p><p>yield实现的功能就像一块肥肉一样，没有那种语言想要放弃这种功能。</p><p>python在yield的基础上实现了asyncio模块。下一节我浅谈一下asyncio这个模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;yield&quot;&gt;&lt;a href=&quot;#yield&quot; class=&quot;headerlink&quot; title=&quot;yield&quot;&gt;&lt;/a&gt;yield&lt;/h2&gt;&lt;p&gt;函数可以看成是一堆指令的集合。在函数中加入yield可以把一个函数变成一个generator，虽然调用的方式不一样了，但是其实现的功能和原来的函数基本是一样的。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://beian.miit.gov.cn/categories/python/"/>
    
    
      <category term="asyncio yield" scheme="http://beian.miit.gov.cn/tags/asyncio-yield/"/>
    
  </entry>
  
  <entry>
    <title>线程与协程</title>
    <link href="http://beian.miit.gov.cn/posts/thread-and-collaboration.html"/>
    <id>http://beian.miit.gov.cn/posts/thread-and-collaboration.html</id>
    <published>2017-10-24T13:36:09.000Z</published>
    <updated>2019-12-09T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>多线程模型中<strong>内核</strong>实现线程与线程之间的调度，通常一个线程是无法从头到尾占用着cpu的，尤其是进行i/o操作时，许多的系统调用都是阻塞的，此时内核保存该线程的上下文，然后挂起该线程。当然更多时候是由于该线程的本次运行时间耗尽，只得被挂起等待cpu的下一次临幸</p><p>但是多线程存在两个问题，在线程数量过多时，问题被放大的尤为明显</p><ul><li>线程的上下文切换造成的开销。    </li><li>线程之间对资源的竞争问题。</li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</p><ol><li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，</li><li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复</li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</li></ol><p>这里的切换有一个时间片的概念</p><p>时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理<strong>公平</strong>，一种方法就是引入时间片，每个程序轮流执行。</p><blockquote><p>在函数调用的时候就已经确定该函数是否会造成阻塞</p></blockquote><p>在I/O密集型运算中，尤其是高并发时。为了保证公平，时间片的分配会越来越小，切换越发频繁。资源也就被浪费在了上下文切换中</p><p>而cpu密集型运算中，不需要频繁的切换线程，所以多线程是一个不错的选择</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>为了解决I/O密集型运算内核在资源调度上的缺陷，所以引入了协程（coroutine）的概念。协程也被称为用户态的线程，内核态的线程调度由内核来完成。而用户态的线程的调度则交给用户来完成，也就是应用程序，也就是我们自己，因此我们可以实现自己的调度算法。更重要的是，即使我们有成千上万的线程，也不用担心线程切换浪费的资源问题了。</p><p>上面我们看到要实现线程的调度的关键就是上下文状态的保存。php中，我们通过 <code>Generator</code>对象来实现程序的中断与恢复。<code>Generator</code> 对象在程序中断时会为我们保存中断前的现场。只要有这一点，我们的应用程序就可以自己实现协程了。这里Generator如何保存上下文环境，是否像线程切换一样浪费资源还需要近一步了解。</p><p>我们可以用协程实现一个支持高并发的web服务器，如图</p><p><img src="http://asset.eienao.com/17-10-24/25490956.jpg" alt></p><p>我们将在单个进程中同时处理这些并发的请求，从http请求开始接手，一点一点推进，直到response。图中的每一个线程其实就是我们所说的协程，我们要做的就是实现一个调度器，来分配上面每一个线程的运行时间。</p><p>具体的实现就参见 鸟哥翻译的这篇文章 <a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">在PHP中使用协程实现多任务调度</a></p><p>读完文章我依旧有两个问题</p><ul><li>系统调用一定要使用非阻塞版本，否则会把控制权交还给内核，然后阻塞整个进程，有解决办法吗？</li><li>对mysql的操作是否属于I/O操作，是否会造成阻塞？</li></ul><p>啰嗦一下nginx采用的是异步I/O模型来实现I/O，另外一个说法是，协程解决了异步I/O噩梦般的回调。另外读完鸟哥的那篇文章然后跟着敲了一下代码发现好像并没有什么卵用~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;多线程模型&quot;&gt;&lt;a href=&quot;#多线程模型&quot; class=&quot;headerlink&quot; title=&quot;多线程模型&quot;&gt;&lt;/a&gt;多线程模型&lt;/h3&gt;&lt;p&gt;多线程模型中&lt;strong&gt;内核&lt;/strong&gt;实现线程与线程之间的调度，通常
      
    
    </summary>
    
    
  </entry>
  
</feed>
