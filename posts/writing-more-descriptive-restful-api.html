<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 编写更具有描述性的 RESTful API · weiwenhao</title><meta name="description" content="编写更具有描述性的 RESTful API - 粤ICP备18153286"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://beian.miit.gov.cn/atom.xml" title="weiwenhao"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/weiwenhao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">编写更具有描述性的 RESTful API</h1><div class="post-info">2018年4月1日</div><div class="post-content"><p>我时常觉得后端应该关心的是数据，而不是业务。<br>因此我希望能够在数据的基础上编写一套接口 能够满足h5端、pc端、ios/android端、包括小程序端等等80%的需求</p>
<a id="more"></a>
<p>laravel + dingo/api 对于api开发来说已经足够友好了，因此选择在它的基础上构建。</p>
<p>预备的知识</p>
<ul>
<li>laravel</li>
<li>RESTful</li>
<li>dingo/api</li>
</ul>
<h2 id="查询Filter"><a href="#查询Filter" class="headerlink" title="查询Filter"></a>查询Filter</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序字段的选择在网上有很多种</p>
<ol>
<li><code>?sort_field=created_at&amp;sort_order=asc</code> </li>
<li><code>?order=+created</code></li>
<li><p><code>?sort_by=created_at&amp;order=asc</code><br>…</p>
<p>这里选择在第三种方式,在可读性和数据处理上更加方便</p>
</li>
</ol>
<p><strong>url：</strong> <code>http://api.test/api/posts?sort_by=created_at&amp;order=desc</code></p>
<p><strong>laravel：</strong> <code>$query-&gt;orderBy(request()-&gt;get(&#39;sort_by&#39;, &#39;id&#39;), request()-&gt;get(&#39;order&#39;, &#39;desc&#39;))</code></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>对于分页来说 <code>offset/limit</code>和<code>page/per_page</code> 又是两个纠结的选择<br>常见的分页需求有两种，一种时普通的ajax分页，另外一种是下拉加载更多分页<br>ajax分页相比于加载更多 通常需要一个total</p>
<p>因此选择能同时适应两种分页需求的 <code>page/per_page</code>，laravel和dingo/api对该方式的支持也足够好</p>
<p><strong>url：</strong> <code>http://maxwei.me/api/posts?per_page=3&amp;page=2</code></p>
<p><strong>laravel：</strong> <code>$query-&gt;paginate(request()-&gt;get(&#39;per_page&#39;, 15))-&gt;appends(request()-&gt;except(&#39;page&#39;))</code></p>
<p><strong>返回结果中的links示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;links&quot;: &#123;</span><br><span class="line">        &quot;next&quot;: &quot;http://api.test/api/posts?order=asc&amp;page=3&quot;,</span><br><span class="line">        &quot;previous&quot;: &quot;http://mp.test/api/diaries?order=asc&amp;page=1&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="字段筛选"><a href="#字段筛选" class="headerlink" title="字段筛选"></a>字段筛选</h3><p><strong>api：</strong> <code>api.test/users?fields=id,nickname,avatar</code> 对于user表中的phone，password字段推荐使用Model的hidden属性隐藏。<br><strong>laravel：</strong> <code>!is_null(request()-&gt;get(&#39;fields&#39;)) &amp;&amp; $query-&gt;addSelect(explode(&#39;,&#39;, request()-&gt;get(&#39;fields&#39;)));</code></p>
<p>transform()的常用写法和fields有一定的冲突，还没有找到比较优雅的解决方案。</p>
<h3 id="where筛选"><a href="#where筛选" class="headerlink" title="where筛选"></a>where筛选</h3><p>当我们只想要状态为1的文章时 我希望可以这么做<br><strong>url：</strong> <code>http://api.test/api/posts?status=1</code></p>
<p>当我想要标签id为1, 2的文章时则这样<br><strong>url：</strong> <code>http://api.test/api/posts?tag_id=1,2</code></p>
<p>当我… 够了，简单点是我所追求的，我不希望去创建一些规则满足模糊查询、notIn、orWhere、嵌套where等等。这不具有通用性，如果需要可以创建一些特定的路由去满足这些条件即可。</p>
<p><strong>laravel:</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$where = [<span class="string">'status'</span>, <span class="string">'tag_id'</span>] <span class="comment">//这是我希望能够被筛选的字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($where <span class="keyword">as</span> $item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null($value = request()-&gt;get($item))) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str_contains($value, <span class="string">','</span>)) &#123;</span><br><span class="line">        $query-&gt;whereIn($item, explode(<span class="string">','</span>, $value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $query-&gt;where($item, <span class="string">'='</span>, $value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源嵌套"><a href="#资源嵌套" class="headerlink" title="资源嵌套"></a>资源嵌套</h2><p>有如下两种需求场景</p>
<ul>
<li>获取某个用户/或标签下的所有文章</li>
<li>获取首页的精选文章</li>
</ul>
<p>我希望这两种情况都能通过一个index()方法得到解决，因此我这样做</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#api.php</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 主资源路由 </span></span><br><span class="line"> $api-&gt;resource(<span class="string">'posts'</span>, <span class="string">'PostController'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多对多关系嵌套路由</span></span><br><span class="line"> $api-&gt;get(<span class="string">'tags/&#123;tag&#125;/posts'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</span><br><span class="line">     $tags = \App\Models\Tag::findOrFail($id);</span><br><span class="line">     <span class="keyword">return</span> app()-&gt;call(<span class="string">'App\Http\Controllers\Api\PostController@index'</span>, [<span class="string">'query'</span> =&gt; $tags-&gt;posts()]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 一对多关系嵌套路由</span></span><br><span class="line"> $api-&gt;get(<span class="string">'users/&#123;user&#125;/posts'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</span><br><span class="line">     $user = \App\Models\User::findOrFail($id);</span><br><span class="line">     <span class="keyword">return</span> app()-&gt;call(<span class="string">'App\Http\Controllers\Api\PostController@index'</span>, [<span class="string">'query'</span> =&gt; $user-&gt;posts()]);</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 上面的代码非常的有规律，可以进行一次封装，而不是这样不行的重复解析。laravel5.6支持的路由模型注入是个不错的注意，但是dingo/api目前还不支持</span></span><br><span class="line"> <span class="comment">// 别忘了在你模型中定义相应的关联关系</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># PostController.php</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">($query = null)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// parseFilter是我封装的一个用来解析通用参数的方法</span></span><br><span class="line">     $paginator = <span class="keyword">$this</span>-&gt;parseFilter($query ?? Post::query());</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;paginator($paginator, <span class="keyword">new</span> PostTransformer());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源关联"><a href="#资源关联" class="headerlink" title="资源关联"></a>资源关联</h2><p>dingo/api + Fractal 对资源关联处理非常优雅，并且很好的解决了n+1 问题。</p>
<p>假设两个需求</p>
<ul>
<li>当我取出多个文章资源时我希望能够关联它们的作者。</li>
</ul>
<p><strong>url：</strong> <code>http://api.test/posts?include=user:field(id|name|avatar)</code></p>
<ul>
<li>取出一个社区资源并附带几名活跃的用户资源，以及这些活跃用户最近发表过的3篇文章时<br><strong>url：</strong> <code>http://api.test/hubs/1?include=hot_users:limit(3).posts:fields(id|title):limit(3)</code></li>
</ul>
<p>这大概就是我非常喜欢fractal而迟迟不肯使用laravel5.5的resources的原因， 因为它制定出了一套include的规则和相应的代码处理，使得代码的偶合性非常低。</p>
<blockquote>
<p>include参数的详细使用方式 请参考dingo/api文档 和 fractal文档 <a href="https://fractal.thephpleague.com/" target="_blank" rel="noopener">https://fractal.thephpleague.com/</a></p>
</blockquote>
<p>对于上面的需求我们可以这么做</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeUser</span><span class="params">(Post $post, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// fractal会帮我们解析include中的参数，并注入到 $params中。因此我们直接使用</span></span><br><span class="line">    $user = $post-&gt;user()-&gt;select($params[fields] ?? <span class="string">'*'</span>)-&gt;firstOrFail();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;item($user, <span class="keyword">new</span> UserTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># HubTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeHotUsers</span><span class="params">(Hub $hub, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $users = $hub-&gt;hot_users()</span><br><span class="line">        -&gt;limit($params[<span class="string">'limit'</span>][<span class="number">0</span>] ?? <span class="number">5</span>)</span><br><span class="line">        -&gt;get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;collection($users, <span class="keyword">new</span> UserTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># UserTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includePosts</span><span class="params">(User $user, ParamBag $params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $post = $user-&gt;posts()</span><br><span class="line">        -&gt;select($params[fields] ?? [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'like_count'</span>])</span><br><span class="line">        -&gt;limit($params[<span class="string">'limit'</span>][<span class="number">0</span>] ?? <span class="number">5</span>)</span><br><span class="line">        -&gt;get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;collection($posts, <span class="keyword">new</span> PostTransformer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充一下， 对于使用了 <code>$this-&gt;response()-&gt;collection()</code>和<code>$this-&gt;response-&gt;paginator()</code> 方法的资源。 dingo/api 会去解析url中的include参数，然后去调用模型的相应的关联方法来进行预加载，从而解决查询的n+1问题</p>
<p>上面的第二个需求，要求Hub模型中必须定义 hot_users和posts 这两个关联方法，否则就会抛出异常</p>
<blockquote>
<p>这里模型定义的关联方法的名称必须与url一致 既 hot_users()。非常难受呀，因为url推荐小写，方法名推荐小驼峰！！</p>
</blockquote>
<h3 id="关联资源的参数过滤规则"><a href="#关联资源的参数过滤规则" class="headerlink" title="关联资源的参数过滤规则"></a>关联资源的参数过滤规则</h3><p><code>:参数名称(值1|值2|值N)</code><br>‘:’ 冒号标志着一个参数的开始<br>紧跟着是参数名称<br>然后接上参数值 其中参数的值需要被括号括起<br>多个参数值时使用 ‘|’ 分隔</p>
<blockquote>
<p>关联资源我并不推荐提供分页参数，因为其会造成数据的重复读取，如果需要取出的关联资源数据量很多。推荐通过单独的api请求获取该资源，而不是通过include方式加载进来。</p>
</blockquote>
<h2 id="资源中的动作"><a href="#资源中的动作" class="headerlink" title="资源中的动作"></a>资源中的动作</h2><p>我们对资源存在一些动作行为，如对帖子的点赞收藏等，这里我选择模仿github的做法，将动作转换为资源。</p>
<h3 id="创建与删除动作资源"><a href="#创建与删除动作资源" class="headerlink" title="创建与删除动作资源"></a>创建与删除动作资源</h3><ul>
<li>点赞文章</li>
</ul>
<p><strong>url:</strong> <code>http://mp.test/posts/1/likes</code><br><strong>method:</strong> <code>POST</code></p>
<ul>
<li>取消点赞文章</li>
</ul>
<p><strong>url:</strong> <code>http://mp.test/posts/1/likes</code><br><strong>method:</strong> <code>DELETE</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PostLikeController.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request, $id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB::table(<span class="string">'user_like_post'</span>)-&gt;insert([</span><br><span class="line">        <span class="string">'user_id'</span> =&gt; \Auth::id(),</span><br><span class="line">        <span class="string">'post_id'</span> =&gt; $id</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;created();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">destroy</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB::table(<span class="string">'user_like_post'</span>)-&gt;where(<span class="string">'user_id'</span>, \Auth::id())-&gt;where(<span class="string">'post'</span>, $id)-&gt;delete();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;noContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证动作资源"><a href="#验证动作资源" class="headerlink" title="验证动作资源"></a>验证动作资源</h3><p>这是一个我研究/纠结了很久的问题，尝试过很多种写法，这里决定模仿知乎的api写法</p>
<p>验证用户是否点赞了某一篇帖子</p>
<p><strong>url：</strong> <code>http://api.test/posts/1?include=is_like</code></p>
<p>对于上面的url，dingo/api 会自动调用PostTransformer的includeIsLike方法。我们只需要在该方法中进行验证即可</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostTransformer.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeIsLike</span><span class="params">(Post $post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这行代码可以根据Auth::id Cache一下</span></span><br><span class="line">    $likePostIds = DB::table(<span class="string">'user_like_post'</span>)-&gt;where(<span class="string">'user_id'</span>, Auth::id())-&gt;pluck(<span class="string">'post_id'</span>)-&gt;toArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;primitive(in_array($diary-&gt;id, $likePostIds));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>吐槽一下 includeIsLike如何返回标量资源，文档上没有任何描述。<br>看了源码才发现primitive这个关键词。😣</p>
<p>对于单个资源可以很容易的完成上面的需求，但对于资源集合我遇到了很大的问题</p>
<p><strong>url：</strong> <code>http://api.test/posts?include=is_like</code></p>
<p>集合我统一使用了<code>$this-&gt;response-&gt;paginator()</code>， 前面提到 paginator和collection方法，会去检测include参数并调用模型的相应的关联方法来进行预加载。 所以会去posts模型去找is_like方法，可是我真的定义不出一个is_like关联关系呢。<br>而且这个行为是没法优雅的禁止掉的，想要禁止？ok啊，那就全关了，别想我再给你解决n+1问题了</p>
<p>这明明是一个很容易解决的问题，在dingo/api的issue中也提到了多次。但是都没有得到解决。</p>
<blockquote>
<p>于是我fork下了dingo/api的代码准备解决一下这个问题时，我终于明白是为什么了~<br>dingo/api和Fractal是不同作者的项目。dingo/api是为laravel量身打造的。其依赖的transform使用的是Fractal。 而Fractal并不专属于laravel.<br>在dingo/api中做很容易，但是在Fractal中添加一个为laravel服务的扩展就有些不切实际了</p>
</blockquote>
<p>既然如此就在我们的项目中稍微解决一下这个问题</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个根Transformers.php 所有的Transformer都继承自该Transformer</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Transformers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">TransformerAbstract</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span> <span class="keyword">extends</span> <span class="title">TransformerAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $disableEagerLoadedIncludes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDisableEagerLoadedIncludes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;disableEagerLoadedIncludes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Fractal.php 并继承于原有Fractal</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fractal</span> <span class="keyword">extends</span> \<span class="title">Dingo</span>\<span class="title">Api</span>\<span class="title">Transformer</span>\<span class="title">Adapter</span>\<span class="title">Fractal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeEagerLoads</span><span class="params">($transformer, $requestedIncludes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $includes = array_merge($requestedIncludes, $transformer-&gt;getDefaultIncludes());</span><br><span class="line">        $includes = array_diff($includes, $transformer-&gt;getDisableEagerLoadedIncludes());</span><br><span class="line">        $eagerLoads = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($includes <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            $eagerLoads[] = is_string($key) ? $key : $value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $eagerLoads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 dingo/api的配置文件api.php 将原有的Fractal更改为我们自定义的</span></span><br><span class="line"></span><br><span class="line"><span class="string">'transformer'</span> =&gt; env(<span class="string">'API_TRANSFORMER'</span>, \App\Services\Fractal::class),</span><br></pre></td></tr></table></figure>
<p>大功告成~ 接下来我们只需要在PostTransformer中定义一个 disableEagerLoadedIncludes属性来添加不需要急切加载的属性了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $disableEagerLoadedIncludes = [<span class="string">'is_like'</span>];</span><br></pre></td></tr></table></figure>
<p>终于可以  <code>?include=is_like,like_count,is_author,balala...</code> 面向include的编程了</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面说的都是已查询为主，但增删改也有一些小技巧 如创建资源除了使用 dingo/api封装的<code>$this-&gt;response-&gt;created()</code>外， 使用<code>$this-&gt;response-&gt;item($post, new PostTransformer())-&gt;setStatusCode(201);</code>也是一种不错的选择。</p>
<p>使用 request进行表单验证、使用 Policiy进行权限验证、使用Observer进行副作用的处理等等，从而保证增删改的代码更具有可读性和解耦性。</p>
<p>另外还有很多待解决的问题</p>
<ul>
<li>如嵌套资源中，直接在路由文件中处理逻辑并不优雅</li>
<li>fields 筛选字段对 Transform的传统写法并不友好 有待改进</li>
<li>fields方法在laravel中显得和include有些冲突，是否可以直接在include中编写需要获取的fields呢<ul>
<li>这里我觉得可能需要抛弃原有transform()的写法，数据处理应该通过orm提供的一些修改器来进行。更多的数据处理则交给客户端，服务端提供一些更加raw的数据。</li>
</ul>
</li>
<li><p>当一个界面过于复杂时，需要请求多次api，超过3次以上我就有些难以接受了，get请求url过长问题，接下来会尝试进行路由的映射 组装操作等操作解决这个问题</p>
</li>
<li><p>资源暴露是否会带来安全问题？这一点我觉不会。如何认证和限流参考dingo/api文档即可</p>
</li>
<li>对于一些不符合RESTful资源的需求如何处理，如搜索需求。可以尝试创建些额外的路由来处理这些额外的需求。这些需求可以占到一个项目的20%左右</li>
<li>资源控制器的index方法使用的page每次都会多查询一条总记录数的sql。</li>
<li><p>资源控制器的index方法如果不存在筛选条件时如何做资源限制，总不能一次取出所有的资源</p>
<ul>
<li><p>突发奇想采用了一个sql黑名单的机制</p>
  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">isBlacklist</span><span class="params">($query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $limit = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request(<span class="string">'per_page'</span>) &amp;&amp; request(<span class="string">'per_page'</span>) &lt; $limit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $key = <span class="string">'sql:'</span>. $query-&gt;toSql();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Cache::has($key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($query-&gt;count() &gt; $limit) &#123;</span><br><span class="line">                Cache::forever($key, date(<span class="string">'Y-m-d H:i:s'</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>…</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>再次说明一下我在做什么，我希望能够在数据的基础上编写一套接口能够满足h5端、pc端、ios/android端、包括小程序端等等80%的需求。<br>我不希望我的接口要跟着每一次的业务变动而去修改，我希望自己关心的是数据，而不是业务。<br>我希望只要知道产品的原型，就能完成后端80%的开发， 而不是等设计定稿/等前端开发等等</p>
<p>现在前端的开发是模块化的，在我看来就是面向import的开发。<br>传统的RESTful接口没法适应于前端的模块化开发。存在着大量的字段冗余和http请求，这是我在学习graphQL的时看到的一句话。</p>
<p>但既然前端的开发是模块化的、面向import的，后端的api接口为什么不能是面向include的呢 😆</p>
<blockquote>
<p>持续关注中 - 希望你能分享在RESTful API、dingo/api、laravel api等开发时的经验、想法和技巧~<br>我将会总结出一份代码demo并分享出来</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/posts/do-you-really-know-git.html" class="prev">PREV</a><a href="/posts/a-deep-understanding-of-the-tcp-protocol-1.html" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'maxwei';
var disqus_identifier = 'posts/writing-more-descriptive-restful-api.html';
var disqus_title = '编写更具有描述性的 RESTful API';
var disqus_url = 'http://beian.miit.gov.cn/posts/writing-more-descriptive-restful-api.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//maxwei.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2020 <a href="http://beian.miit.gov.cn">粤ICP备18153286</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113144905-1",'auto');ga('send','pageview');</script></body></html>