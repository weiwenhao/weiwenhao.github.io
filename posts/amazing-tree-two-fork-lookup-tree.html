<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Amazing tree —— 二叉查找树 · weiwenhao</title><meta name="description" content="Amazing tree —— 二叉查找树 - 粤ICP备18153286"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://beian.miit.gov.cn/atom.xml" title="weiwenhao"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/weiwenhao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Amazing tree —— 二叉查找树</h1><div class="post-info">2018年4月20日</div><div class="post-content"><blockquote>
<p>二分查找很好的解决了查找问题，将时间复杂度从 O(n)降到了O(logn)。<br>但是二分查找的前提条件是数据必须是有序的，并且具有线性的下标。<br>对于线性表，可以很好的应用二分查找，但是在插入和删除操作时则可能会造成整个线性表的动荡，时间复杂度达到了O(n)<br>链表更是没法应用二分查找。</p>
</blockquote>
<p>于是有了下面将要介绍的算法，其在查找、插入、删除都能够达到O(logn)的时间复杂度 —— <strong>二叉查找树</strong></p>
<a id="more"></a>
<p>见名知意，其数据结构基础为二叉树，初次接触到二叉树时并没有感觉到其有什么突出之处。但看到通过二叉树构建出的二叉查找树方案时，确被深深的震撼了。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<p>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>任意结点的左、右子树也分别为二叉查找树；<br>没有键值相等的结点。</p>
<p>根据上面的规则我们先来定义一颗二叉树<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a99f8188?w=478&amp;h=468&amp;f=jpeg&amp;s=29956" alt></p>
<p>这里可以很容易看出其规律，不需要过多的解释。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>现在再插入一个元素13。 13&gt;12所以往右边走来到14，13 &lt; 14则左走，发现14没有左孩子，所以将13插入之，得到下面这张图<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9a9885d?w=534&amp;h=483&amp;f=jpeg&amp;s=35531" alt></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>按照上面插入的思路，可以很容易实现搜索操作。并且发现其查找的时间复杂度就为这颗树的深度。</p>
<blockquote>
<p>根据完全二叉树的性质，具有n个结点的完全二叉树的深度为 <code>[logn] + 1</code></p>
</blockquote>
<p>忽略掉<code>+1</code>得到二叉查找树的查找时间复杂度为 <code>O(logn)</code>，但是实际上并非如此，后面我们分析。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉树的遍历有前序、中序、后序遍历三种方式，这里着重介绍后序遍历。<br>对二差查找树进行中序遍历时，可以得到一个<code>asc</code>的排序结果。如上面的树中序遍历的结果是 <strong>3, 8, 9, 12, 13, 14</strong>。<br><code>中序遍历从一颗子树最左的节点开始输出，既该树的最小值</code>。实现中序遍历只需要将<strong>数据收集点</strong>置于左递归点与右递归点之间，这样说还是有些含糊了，看代码吧</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">inorder</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;left) &#123;</span><br><span class="line">        $data = array_merge($data, <span class="keyword">$this</span>-&gt;inorder($root-&gt;left)); <span class="comment">//左孩子递归点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $data[] = $root-&gt;data; <span class="comment">// 这里是中序遍历的数据收集点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;right) &#123;</span><br><span class="line">        $data = array_merge($data, <span class="keyword">$this</span>-&gt;inorder($root-&gt;right)); <span class="comment">// 右孩子递归点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前驱与后继， 以9节点为例， 12属于9的后继，8属于9的前驱。</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>我们给这颗树多加几个结点<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0add13dd2?w=968&amp;h=703&amp;f=jpeg&amp;s=76963" alt></p>
<p>删除树中的结点分为很多种情况，如被删除的结点不存在子结点，只存在左子树/右子树，左右子树都存在，这里已覆盖率最广的左右子树都存在为例。</p>
<blockquote>
<p>分析一个需求时要并不是需求存在多少中情况我们就写多少种情况。而应该分析情况之间的关系，是否存在重复，或者属于关系等，程序员应该做的就是提取需求的本质，力求于最简洁的实现</p>
</blockquote>
<p>现在我们打算删除25这个结点，你会怎么做？<br>如果只是简单把18来顶替原来25的位置，则需要对18这颗子树的孩子们进行重新调整。18只有三个孩子还好，但是当孩子成千上万时，显然会造成大面积的调整。<br>所以我希望能够找到一个更好的节点来代替25，按照算法导论中的描述，我们应该寻找该结点的前驱或者后继来代替，比如图中的24和27分别是25的前驱和后继。</p>
<blockquote>
<p>为什么要使用前驱或者后缀来代替？这点我十分不确定，我给自己的理由是</p>
<ol>
<li>该结点是一个特殊值，属于某颗子树的最大值或者最小值，具有确定性，可以被比较好的定义且查找出来。</li>
<li>由于该结点属于被删除节点的前驱或者后继，则删除该结点对数据结构造成的影响最小。<em>我并不确定是对什么的数据结构造成的影响最小</em></li>
</ol>
</blockquote>
<p>上面描述的情况的图解如下 ↓<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9bdc5fc?w=756&amp;h=537&amp;f=jpeg&amp;s=50523" alt><br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0a9b88949?w=696&amp;h=457&amp;f=jpeg&amp;s=47267" alt></p>
<p>删除还存在一些其他的情况,比如下面这种情况↓<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0ae694229?w=909&amp;h=529&amp;f=jpeg&amp;s=52024" alt></p>
<p>对于这种情况直接将30提升到25即可，接下来看一下看php的代码实现：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span><span class="params">($root, $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!$root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($root-&gt;data === $data) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;left) &#123;</span><br><span class="line">            <span class="comment">// 左转</span></span><br><span class="line">            $node = $root-&gt;left;</span><br><span class="line"></span><br><span class="line">            $parent = $root;</span><br><span class="line">            $toward = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ($node-&gt;right) &#123;</span><br><span class="line"></span><br><span class="line">                $parent = $node;</span><br><span class="line">                $toward = <span class="string">'right'</span>;</span><br><span class="line"></span><br><span class="line">                $node = $node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $root-&gt;data = $node-&gt;data;</span><br><span class="line"></span><br><span class="line">            $parent-&gt;&#123;$toward&#125; = <span class="keyword">$this</span>-&gt;delete($node, $node-&gt;data);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> $root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($root-&gt;data &gt; $data) &#123;</span><br><span class="line">        <span class="comment">// 如果root的左孩子没有被删除,那就原样返回回来, 如果被删除了,那就找个孩子代替</span></span><br><span class="line">        $root-&gt;left = <span class="keyword">$this</span>-&gt;delete($root-&gt;left, $data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $root-&gt;right = <span class="keyword">$this</span>-&gt;delete($root-&gt;right, $data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于php有内存回收机制，因此我们没有办法像c一样直接去修改内存，所以这里借助递归的特性来解决这个问题 <code>$root-&gt;left = $this-&gt;delete($root-&gt;left, $data);</code> 做类似这样一个处理，这可能会有些理解上的困难。但总归还是能够明白的~</p>
<p>除了递归解决外，也可以用下面这种办法。<br>即定义一个parent和toward来做一个导向，这在上面的代码中也有体现。<strong>该方法更加适用于迭代处理</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$parent = $root;</span><br><span class="line">$toward = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($node-&gt;right) &#123;</span><br><span class="line"></span><br><span class="line">    $parent = $node;</span><br><span class="line">    $toward = <span class="string">'right'</span>;</span><br><span class="line"></span><br><span class="line">    $node = $node-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更详细的实习细节和调用示例请参考单元测试。</p>
<p><a href="https://github.com/weiwenhao/algorithm/blob/master/test/BinarySearchTreeTest.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/test/BinarySearchTreeTest.php</a></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><a href="https://github.com/weiwenhao/algorithm/blob/master/src/BinarySearchTree.php" target="_blank" rel="noopener">https://github.com/weiwenhao/algorithm/blob/master/src/BinarySearchTree.php</a></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于php没有像js一样的字面量对象或者c一样的struct。因此直接使用对象来表示树中的结点</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $data;</span><br><span class="line">    <span class="keyword">public</span> $left;</span><br><span class="line">    <span class="keyword">public</span> $right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($data, $left = null, $right = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = $data;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = $left;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = $right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查找的时候指出了，二叉查找树的查询的时间复杂度并不是严格意义上的O(logn) 是因为有这样的情况发生， 假设需要插入 <strong>12, 10, 9, 5, 4, 1</strong>这几个数据，那么我们会得到这样一颗歪脖子树</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0e77d4df1?w=628&amp;h=729&amp;f=jpeg&amp;s=29661" alt><br>此时的时间复杂度俨然已经变成了O(n)，不过对于这样的问题自然已经有解决方案。下一节将会在<strong>AVL树</strong>和<strong>红黑树</strong>这两种解决方案中选一种来BB~</p>
<p>当然二叉查找树依旧是各种树的根基，还请认真理解。<br><img src="https://user-gold-cdn.xitu.io/2018/4/20/162e36b0e7d2e92c?w=788&amp;h=162&amp;f=jpeg&amp;s=22352" alt></p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/introduction-of-kmp-algorithm-and-derivation-of-next-array.html" class="prev">PREV</a><a href="/posts/dijkstra-algorithm-and-correctness-analysis.html" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'maxwei';
var disqus_identifier = 'posts/amazing-tree-two-fork-lookup-tree.html';
var disqus_title = 'Amazing tree —— 二叉查找树';
var disqus_url = 'http://beian.miit.gov.cn/posts/amazing-tree-two-fork-lookup-tree.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//maxwei.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2020 <a href="http://beian.miit.gov.cn">粤ICP备18153286</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113144905-1",'auto');ga('send','pageview');</script></body></html>