<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> MySQL 中 JSON 字段的使用技巧 · weiwenhao</title><meta name="description" content="MySQL 中 JSON 字段的使用技巧 - 粤ICP备18153286"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://beian.miit.gov.cn/atom.xml" title="weiwenhao"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/weiwenhao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MySQL 中 JSON 字段的使用技巧</h1><div class="post-info">2018年12月12日</div><div class="post-content"><p>mysql5.7.8之后开始原生支持json. 在类似mongodb这种nosql数据库中,json存储数据是非常自然的, 在mysql中合理的使用json,能够带来极大的便利</p>
<a id="more"></a>
<h4 id="Json字段的使用场景"><a href="#Json字段的使用场景" class="headerlink" title="Json字段的使用场景"></a>Json字段的使用场景</h4><p>在读laravel手册举例子时,我们经常会看到 <code>$user-&gt;is_admin</code> 来判断用户是否为管理员,但是在用户表中,admin往往只占很小一部分.如果单开一个is_admin字段是很没有必要的行为.数据库中会有大量的无意义数据存储, 我们可以为user表创建一个 json 字段,来存储我们的is_admin字段</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        username: 'weiwenhao',</span><br><span class="line">        rest: &#123; // 冗余字段</span><br><span class="line">            is_admin: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        username: 'eienao',</span><br><span class="line">        rest: null</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然即使不使用json,我们也不会使用is_admin来判断是否为管理员.</p>
<p>可以通过新增admin表或者RABC来标志管理员</p>
</blockquote>
<p>依旧是用户表, 很常见的一个需求是第三方登录,如果我们使直接在user表新增<code>facebook_id,facebook_email,facebook_phone_number,google_id,....</code>字段, 可以预见这会造成大量的无意义数据(即使他们不占用内存,或者影响性能)</p>
<blockquote>
<p>一种解决办法是 使用一对多关系来解决, 既建立一个 第三方登录表来存储第三方登录的id/email/phone_number等</p>
</blockquote>
<p>但是我更喜欢使用json字段来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        username: &apos;weiwenhao&apos;,</span><br><span class="line">        rest: &#123;</span><br><span class="line">            is_admin: 1,</span><br><span class="line">            facebook_id: 2348234,</span><br><span class="line">            facebook_phone_number: 2834723234,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        username: &apos;eienao&apos;,</span><br><span class="line">        rest: &#123;</span><br><span class="line">            google_id: 2348234,</span><br><span class="line">            google_email: xxx@gmail.com</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看出,使用json字段使数据表的设计更加自然,集中,业务也相应的更加的简单方便.</p>
<h4 id="Json字段在laravel中的使用"><a href="#Json字段在laravel中的使用" class="headerlink" title="Json字段在laravel中的使用"></a>Json字段在laravel中的使用</h4><p>首先是迁移文件 <code>$table-&gt;json(&#39;rest&#39;)-&gt;nullable();</code> </p>
<p>laravel对json的使用进行了一定的优化,对于更新和创建我们可以.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$user = <span class="keyword">new</span> User;</span><br><span class="line">$user-&gt;&#123;<span class="string">'rest-&gt;google_id'</span>&#125; = <span class="string">'xxx'</span>; </span><br><span class="line"><span class="comment"># 如果你的rest字段为null,那么上面的操作会使 null 会变成 &#123;google_id: "xxx"&#125;, 不需要再做 是否为null的判定啦</span></span><br><span class="line"><span class="comment"># 如果仅使用上面的插入操作,也不需要在使用模型的修改器来吧 json =&gt; array, array =&gt; json啦</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当rest字段的值为null时,批量操作无法执行, 类似  <code>update([&#39;rest-&gt;google_id&#39; =&gt; &#39;xxx&#39;])</code> 这样的操作执行无效,因此更推荐上面的方式来进行更新操作</p>
</blockquote>
<p>对于查找操作可以方便的使用</p>
<p><code>User::where(&#39;rest-&gt;google_id&#39;,&#39;xxx&#39;)-&gt;firstOrFail()</code></p>
<blockquote>
<p> 关于检索的效率问题,在后面内容中给出解决方案</p>
</blockquote>
<h4 id="Generated-Column-生成列"><a href="#Generated-Column-生成列" class="headerlink" title="Generated Column (生成列)"></a>Generated Column (生成列)</h4><p>5.7新增了生成列, 生成列的值是根据列定义中包含的表达式计算得来.官方示例:计算直角三角形的斜边的长度</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle (</span><br><span class="line">  sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) # <span class="keyword">AS</span> (expression) 为生成列的核心语法</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> triangle (sidea, sideb) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"># 对于上面的插入,查询可以得到如下结果</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM triangle;</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br><span class="line">| sidea | sideb | sidec              |</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br><span class="line">|     1 |     1 | 1.4142135623730951 |</span><br><span class="line">|     3 |     4 |                  5 |</span><br><span class="line">|     6 |     8 |                 10 |</span><br><span class="line">+<span class="comment">-------+-------+--------------------+</span></span><br></pre></td></tr></table></figure>
<p>上面的 sidec的值 是根据sidea和sideb计算得来, 并未实际的存储在磁盘中.mysql5.7之前我们想要实现上面的需求可能会这样写sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,(<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) <span class="keyword">as</span> sidec <span class="keyword">FROM</span> triangle;</span><br></pre></td></tr></table></figure>
<p>上面既生成列的主要作用, 实际上生成列有两种子类型,上面的例子属于 virtual (虚拟) 类型的生成列, 其并没有将sidec的值实际存储在磁盘中.</p>
<p>除了virtual, 生成列还支持 stored类型,其创建语句为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#...</span><br><span class="line">sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb)) STORED # stored不指定则默认为 virtual</span><br><span class="line">#...</span><br></pre></td></tr></table></figure>
<p>当行创建或者更新时, 会重新计算 sidec并将其存储在磁盘中</p>
<p>生成列的另一个重要的特性是可以根据<strong>生成列表达式的计算结果建立索引</strong>. 其建立索引的方式和普通字段创建索引的方式一致.1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle (</span><br><span class="line">  sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">  sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="keyword">SQRT</span>(sidea * sidea + sideb * sideb)) # <span class="keyword">AS</span> (expression) 为生成列的核心语法</span><br><span class="line">  <span class="keyword">INDEX</span>(<span class="string">`sidec`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>索引本身也是存储在磁盘中的实际存在的物质, 因此 virtual 生成列 + 索引,可以达到存储空间的最有效利用. </p>
<blockquote>
<p>对于stored 生成列 + 索引, 通常不会访问到存储在磁盘中stored 生成列,而是直接访问索引.因此没有必要使用stored生成列</p>
</blockquote>
<h4 id="使用生成列为json中的字段添加索引"><a href="#使用生成列为json中的字段添加索引" class="headerlink" title="使用生成列为json中的字段添加索引"></a>使用生成列为json中的字段添加索引</h4><p>已user表的rest.google_id为例,建表操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#...</span><br><span class="line">`rest` json NULL,</span><br><span class="line"></span><br><span class="line"># JSON_EXTRACT(`rest`,'$.google_id') 等价于 `rest`-&gt;'$.google_id'</span><br><span class="line"># 5.7.13版本后 </span><br><span class="line"># JSON_UNQUOTE(JSON_EXTRACT(`rest`,'$.google_id')) 等价于 `rest`-&gt;&gt;'$.google_id'</span><br><span class="line"># 使用生成列为json添加索引时,请务必使用 JSON_UNQUOTE(JSON_EXTRACT(`rest`,'$.google_id'))/-&gt;&gt;</span><br><span class="line">`google_id` varchar GENERATED ALWAYS AS (`rest`-&gt;&gt;'$.google_id')) NULL</span><br><span class="line"></span><br><span class="line">UNIQUE INDEX(`google_id`)</span><br><span class="line">#...</span><br></pre></td></tr></table></figure>
<p>在laravel迁移文件中</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$table-&gt;json(<span class="string">'rest'</span>)-&gt;nullable();</span><br><span class="line"></span><br><span class="line">$table-&gt;string(<span class="string">'rest'</span>)-&gt;nullable()-&gt;unique()-&gt;virtualAs(<span class="string">'`oauth`-&gt;&gt;"$.google_id"'</span>);</span><br></pre></td></tr></table></figure>
<p>有了索引后,当我们执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="string">`rest`</span>-&gt;<span class="string">'$.google_id'</span> = <span class="string">'xxx'</span> # 通常使用这种更加简单的形式</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="string">`rest`</span>-&gt;&gt;<span class="string">'$.google_id'</span> = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"># 上面两种表达式会被mysql的优化器在查询阶段自动优化为 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> google_id = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure>
<h4 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h4><ul>
<li><p><code>virtualAs(oauth-&gt;&quot;$.google_id&quot;&#39;);</code> 使用 <strong>-&gt;</strong>符号来创建生成列会出现无法使用索引的情况, 原因不是很明了,需要继续研究一下手册. 另外对于创建语句 <code>GENERATED ALWAYS</code>的作用也不是很明了.</p>
</li>
<li><p>关于null, 经常会看到一种言论是mysql中使用null作为字段默认值会出现无法索引的情况.但经过查询了解,发现这是一种老中医理论. 我更倾向于使用null作为默认值, 而不是 ‘’/0/0.0 ,我认为null的表达性更好, laravel中也无时无刻不在提现这种思想.</p>
</li>
<li>关于json的使用, 最近的项目中,我大部分核心表都有一个json字段,做一些非核心数据的存储和冗余. </li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/vue-engineering-best-practices.html" class="prev">PREV</a><a href="/posts/elegant-use-of-routing-model-bindings.html" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'maxwei';
var disqus_identifier = 'posts/tips-for-using-json-fields-in-mysql.html';
var disqus_title = 'MySQL 中 JSON 字段的使用技巧';
var disqus_url = 'http://beian.miit.gov.cn/posts/tips-for-using-json-fields-in-mysql.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//maxwei.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2020 <a href="http://beian.miit.gov.cn">粤ICP备18153286</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113144905-1",'auto');ga('send','pageview');</script></body></html>